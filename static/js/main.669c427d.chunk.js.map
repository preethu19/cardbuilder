{"version":3,"sources":["App.js","index.js"],"names":["Rectangle","shapeProps","isSelected","onSelect","onChange","onMove","shapeRef","React","useRef","trRef","useEffect","current","nodes","getLayer","batchDraw","Fragment","onDblClick","onDblTap","ref","onDragEnd","e","x","target","y","onTransformEnd","node","scaleX","scaleY","width","Math","max","height","boundBoxFunc","oldBox","newBox","Circles","radius","Texts","App","useState","shapes","setShapes","selectedId","selectShape","textEdit","setTextEdit","editShape","setEditShape","tool","setTool","lines","setLines","isDrawing","useTool","setUseTool","handleMouseDown","pos","getStage","getPointerPosition","points","name","index","length","checkDeselect","handleMouseMove","point","lastLine","concat","splice","handleMouseUp","stageRef","onDelete","item","oldData","filter","currentData","id","prevShape","window","innerWidth","innerHeight","onTouchStart","onMouseDown","onTouchEnd","onMousemove","onTouchMove","onMouseup","map","eachShape","i","newAttrs","rects","slice","line","stroke","strokeWidth","tension","lineCap","globalCompositeOperation","draggable","onClick","onTap","onDragStart","prevCircles","uuid","fill","findOne","position","prevRectangles","fontSize","text","prevTexts","textEditVisible","type","value","style","backgroundColor","shape","elem","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.669c427d.chunk.js","sourcesContent":["import \"./App.css\";\n\nimport React, { useState, useRef, useEffect } from \"react\";\nimport { Stage, Layer, Circle, Text, Ellipse, Rect, Transformer, Line } from \"react-konva\";\nimport { v4 as uuid } from 'uuid';\nimport { Html } from \"react-konva-utils\";\n\n\nconst Rectangle = ({ shapeProps, isSelected, onSelect, onMove, onChange }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n  return (\n    <React.Fragment>\n      <Rect\n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        // draggable\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y(),\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            width: Math.max(5, node.width() * scaleX),\n            height: Math.max(node.height() * scaleY),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\n\nconst Circles = ({ shapeProps, isSelected, onSelect, onMove, onChange }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  return (\n    <React.Fragment>\n      <Circle\n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        // draggable\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y(),\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            radius: Math.max(node.radius() * scaleX, node.radius() * scaleY),\n            \n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.radius < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\nconst Texts = ({ shapeProps, isSelected, onSelect, onMove, onChange }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n  \n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  \n  \n \n\n  return (\n    <React.Fragment>\n      <Text\n       \n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        // draggable\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y()\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            \n            width: Math.max(5, node.width() * scaleX),\n            height: Math.max(node.height() * scaleY),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\n\n\n\nexport default function App() {\n  const [circles, setCircles] = useState([]);\n  const [rectangles, setRectangles] = useState([]);\n  const [shapes, setShapes] = useState([]);\n  const [selectedId, selectShape] = useState(null);\n  const [textEdit, setTextEdit] = useState(false)\n  const [editShape, setEditShape] = useState(null)\n  const [tool, setTool] = React.useState('');\n  const [lines, setLines] = React.useState([]);\n  const isDrawing = React.useRef(false);\n  const [useTool, setUseTool] = useState(false)\n\n  const handleMouseDown = (e) => {\n    if(useTool){\n      isDrawing.current = true;\n      const pos = e.target.getStage().getPointerPosition();\n      setShapes([...shapes, { tool, points: [pos.x, pos.y], name: \"line\", index: lines.length }]);\n      setLines([...lines, { tool, points: [pos.x, pos.y], name: \"line\" }]);\n      \n    }\n    checkDeselect(e)\n  };\n\n  const handleMouseMove = (e) => {\n    if(useTool){\n      // no drawing - skipping\n    if (!isDrawing.current) {\n      return;\n    }\n    const stage = e.target.getStage();\n    const point = stage.getPointerPosition();\n    let lastLine = lines[lines.length - 1];\n    // add point\n    lastLine.points = lastLine.points.concat([point.x, point.y]);\n\n    // replace last\n    lines.splice(lines.length - 1, 1, lastLine);\n    setLines(lines.concat());\n\n    // let lastLine = ''\n    // for(var i=shapes.length-1; i > 0;i--){\n    //   if(shapes[i].name=='line'){\n    //     lastLine = shapes[shapes.length - 1];\n    //   }\n    // }\n    \n    // // add point\n    // lastLine.points = lastLine.points.concat([point.x, point.y]);\n\n    // // replace last\n    // shapes.splice(shapes.length - 1, 1, lastLine);\n    // setShapes(shapes.concat());\n    }\n    \n  };\n\n  const handleMouseUp = () => {\n    if(useTool){\n      isDrawing.current = false;\n    }\n    \n  };\n\n  const checkDeselect = (e) => {\n    // deselect when clicked on empty area\n    const clickedOnEmpty = e.target === e.target.getStage();\n    if (clickedOnEmpty) {\n      selectShape(null);\n    }\n    setTextEdit(false)\n  };\n\n  const stageRef = useRef(null);\n  \n  const onDelete = (item) => {\n    setShapes((oldData) => {\n      return (oldData.filter((currentData, index) => {\n        return currentData.id !== item.id;\n      }))\n  })\n  setShapes((prevShape)=>(\n    [...prevShape, item]\n  ))\n}\n\n  const onEdit = (e) => {\n    setEditShape((shape)=> ({...shape, text:e.target.value}))\n    setShapes(shapes.map((elem)=>{\n      if(elem.id==selectedId){\n        return {...elem, text:e.target.value}\n      }\n      return elem\n    })\n    )\n  }\n  return (\n    <>\n    <Stage \n        width={window.innerWidth} \n        height={window.innerHeight} \n        ref={stageRef} \n        onTouchStart={(e)=>{checkDeselect(e);handleMouseDown(e)}} \n        onMouseDown={handleMouseDown}\n        onTouchEnd={handleMouseUp}\n        onMousemove={handleMouseMove}\n        onTouchMove={handleMouseMove}\n        onMouseup={handleMouseUp}\n      >\n      <Layer>\n        \n        \n       \n\n      {shapes.map((eachShape, i)=> {\n        if(eachShape.name==\"rectangle\"){\n            return(\n              <Rectangle\n              key={i}\n              shapeProps={eachShape}\n              isSelected={eachShape.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(eachShape.id);\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = shapes.slice();\n                rects[i] = newAttrs;\n                setShapes(rects);\n              }}\n            />\n            )\n        }\n        else if(eachShape.name==\"circle\"){\n            return(\n              <Circles\n             key={i}\n            shapeProps={eachShape}\n            isSelected={eachShape.id === selectedId}\n            onSelect={() => {\n              setUseTool(false)\n              onDelete(eachShape);\n              selectShape(eachShape.id);\n              \n            }}\n            onMove={()=>onDelete(eachShape)}\n            onChange={(newAttrs) => {\n              const rects = shapes.slice();\n              rects[i] = newAttrs;\n              setShapes(rects);\n            }}\n          />\n        )\n        }\n        else if(eachShape.name==\"text\"){\n          return(\n            <Texts\n              key={i}\n              shapeProps={eachShape}\n              isSelected={eachShape.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(eachShape.id);\n                setEditShape(eachShape)\n                setTextEdit(!textEdit)\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = shapes.slice();\n                rects[i] = newAttrs;\n                setShapes(rects);\n              }}\n            />\n          )\n        }\n        {/* else if(eachShape.name==\"line\"){\n          \n          return(\n            <Line\n              key={i}\n              points={lines[eachShape.index].points}\n              stroke=\"#df4b26\"\n              strokeWidth={5}\n              tension={0.5}\n              lineCap=\"round\"\n              globalCompositeOperation={\n                lines[eachShape.index].tool === 'eraser' ? 'destination-out' : 'source-over'\n              }\n            />\n          )\n         \n        } */}\n      })\n      }\n      \n      {lines.map((line, i) => (\n            <Line\n              key={i}\n              points={line.points}\n              stroke=\"#df4b26\"\n              strokeWidth={5}\n              tension={0.5}\n              lineCap=\"round\"\n              globalCompositeOperation={\n                line.tool === 'eraser' ? 'destination-out' : 'source-over'\n              }\n            />\n          ))}\n\n        <Circle\n          name=\"draggableCircle1\"\n          x={50}\n          y={50}\n          radius={25}\n          stroke=\"black\"\n          id=\"circle1\"\n        />\n        <Circle\n          name=\"draggableCircle\"\n          x={50}\n          y={50}\n          radius={25}\n          stroke=\"black\"\n          draggable\n          id=\"circle2\"\n          onClick={()=>setUseTool(false)}\n          onTap={()=>setUseTool(false)}\n          onDragStart={()=>setUseTool(false)}\n          onDragEnd={(e) => {\n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            setShapes((prevCircles) => [\n              ...prevCircles,\n              { x: e.target.x(), y: e.target.y(), radius: 25, stroke:\"black\", id: uuid(), fill: \"red\", name:\"circle\" }\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableCircle = stage.findOne(\".draggableCircle\");\n            draggableCircle.position({ x: 50, y: 50 });\n          }}\n        />\n\n      <Rect\n        x= {25}\n        y= {80}\n        width= {50}\n        height= {50}\n        stroke=\"black\"\n        id= 'rect1'\n      />\n      <Rect\n        name=\"draggableRect\"\n        x= {25}\n        y= {80}\n        width= {50}\n        height= {50}\n        stroke=\"black\"\n        id= 'rect1'\n        draggable\n        onClick={()=>setUseTool(false)}\n        onTap={()=>setUseTool(false)}\n        onDragStart={()=>setUseTool(false)}\n        onDragEnd={(e) => {\n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            setShapes((prevRectangles) => [\n              ...prevRectangles,\n              { x: e.target.x(), y: e.target.y(), stroke:\"black\", width: 50, height: 50, id: uuid(), fill: \"green\", name:\"rectangle\"}\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableRectangle = stage.findOne(\".draggableRect\");\n            draggableRectangle.position({ x: 25, y: 80 });\n          }}\n      />\n      <Text\n          fontSize={50}\n          text=\"T\"\n          width={40}\n          height={100}\n          x={35}\n          y={140}\n        />\n        <Text\n          name=\"draggableText\"\n          x={35}\n          y={140}\n          text=\"T\"\n          fontSize={50}\n          width={40}\n          height={100}\n          draggable\n          onClick={()=>setUseTool(false)}\n          onTap={()=>setUseTool(false)}\n          onDragStart={()=>setUseTool(false)}\n          onDragEnd={(e) => {\n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            \n            setShapes((prevTexts) => [\n              ...prevTexts,\n              { x: e.target.x(), y: e.target.y(), id: uuid(), text: \"T\", width: 40, textEditVisible:true, height:100, fontSize: 50, name:\"text\"}\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableText = stage.findOne(\".draggableText\");\n            draggableText.position({ x: 35, y: 140 });\n          }}\n      />\n     <Html>\n        <div>\n        <input type=\"button\" value=\"Pencil\" style={tool=='pen' && useTool?{backgroundColor: \"aqua\"}:null} onClick={()=>{setTool('pen'); setUseTool(!useTool)}}/>\n        <input type=\"button\" value=\"Eraser\" style={tool=='eraser' && useTool?{backgroundColor: \"aqua\"}:null} onClick={()=>{setTool('eraser'); setUseTool(!useTool)}} />\n        </div>\n     </Html>\n        \n      </Layer>\n    </Stage>\n    {textEdit?\n      <textarea value={editShape.text} onChange={onEdit}></textarea>\n      :null\n    }\n    <select\n        value={tool}\n        onChange={(e) => {\n          setTool(e.target.value);\n        }}\n      >\n        <option value=\"pen\">Pen</option>\n        <option value=\"eraser\">Eraser</option>\n      </select>\n    </>\n  );\n}\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}