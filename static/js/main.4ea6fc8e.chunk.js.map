{"version":3,"sources":["App.js","index.js"],"names":["Rectangle","shapeProps","isSelected","onSelect","onChange","onMove","useTool","shapeRef","React","useRef","trRef","useEffect","current","nodes","getLayer","batchDraw","Fragment","onDblClick","onDblTap","ref","draggable","onDragEnd","e","x","target","y","onTransformEnd","node","scaleX","scaleY","width","Math","max","height","boundBoxFunc","oldBox","newBox","Circles","radius","Texts","Lines","points","tool","stroke","strokeWidth","tension","lineCap","globalCompositeOperation","newPoints","i","length","concat","history","shapes","lines","historyStep","App","useState","setShapes","selectedId","selectShape","textEdit","setTextEdit","editShape","setEditShape","setTool","setLines","isDrawing","setUseTool","handleDraw","setHandleDraw","gridWidth","window","innerWidth","gridHeight","innerHeight","linesA","linesB","push","handleMouseDown","pos","getStage","getPointerPosition","name","id","uuid","index","checkDeselect","handleMouseMove","point","lastLine","splice","handleMouseUp","slice","stageRef","onDelete","item","oldData","filter","currentData","prevShape","data","JSON","parse","localStorage","getItem","onTouchStart","onMouseDown","onTouchEnd","onMousemove","onTouchMove","onMouseup","map","eachShape","newAttrs","rects","fill","prevCircles","console","log","findOne","position","prevRectangles","fontSize","text","textEditVisible","prevTexts","type","value","onClick","previous","next","stringify","setItem","style","backgroundColor","shape","elem","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4ea6fc8e.chunk.js","sourcesContent":["import \"./App.css\";\n\nimport React, { useState, useRef, useEffect } from \"react\";\nimport { Stage, Layer, Circle, Text, Ellipse, Rect, Transformer, Line } from \"react-konva\";\nimport { v4 as uuid } from 'uuid';\nimport { Html } from \"react-konva-utils\";\n\n\nconst Rectangle = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n  return (\n    <React.Fragment>\n      <Rect\n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y(),\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            width: Math.max(5, node.width() * scaleX),\n            height: Math.max(node.height() * scaleY),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\n\nconst Circles = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  return (\n    <React.Fragment>\n      <Circle\n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y(),\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            radius: Math.max(node.radius() * scaleX, node.radius() * scaleY),\n            \n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.radius < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\nconst Texts = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n  \n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  \n  \n \n\n  return (\n    <React.Fragment>\n      <Text\n       \n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y()\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            \n            width: Math.max(5, node.width() * scaleX),\n            height: Math.max(node.height() * scaleY),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\nconst Lines = ({ shapeProps, isSelected, onSelect, onMove, onChange, points, tool, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n  \n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  \n  \n \n\n  return (\n    <React.Fragment>\n    \n      <Line\n       \n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        points={points}\n        stroke=\"#df4b26\"\n        strokeWidth={5}\n        tension={0.5}\n        lineCap=\"round\"\n        draggable={!useTool && isSelected}\n        globalCompositeOperation={\n          tool === 'eraser' ? 'destination-out' : 'source-over'\n        }\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y()\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n          \n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          let newPoints = [];\n          \n          for (let i=0; i<shapeProps.points.length; i=i+2){\n            newPoints = newPoints.concat([shapeProps.points[i]*scaleX, shapeProps.points[i+1]*scaleY]) \n            \n          }\n          onChange({\n            ...shapeProps,\n            // x: node.x(),\n            // y: node.y(),\n            // set minimal value\n            points: newPoints\n            // width: Math.max(5, node.width() * scaleX),\n            // height: Math.max(node.height() * scaleY),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\nlet history = [{shapes: [], lines:[]}]\nlet historyStep = 0;\n\n\n\n\nexport default function App() {\n  const [circles, setCircles] = useState([]);\n  const [rectangles, setRectangles] = useState([]);\n  const [shapes, setShapes] = useState([]);\n  const [selectedId, selectShape] = useState(null);\n  const [textEdit, setTextEdit] = useState(false)\n  const [editShape, setEditShape] = useState(null)\n  const [tool, setTool] = React.useState('');\n  const [lines, setLines] = React.useState([]);\n  const isDrawing = React.useRef(false);\n  const [useTool, setUseTool] = useState(false)\n  const [handleDraw, setHandleDraw] = useState(false)\n\n  \nconst gridWidth = window.innerWidth/10\nconst gridHeight = window.innerHeight/5\n\nconst linesA = []\nconst linesB = []\n\n  for (let i = 0; i < window.innerHeight; i=i+gridHeight) {\n    linesA.push(\n      <Line\n        strokeWidth={0.5}\n        stroke={'gray'}\n        points={[0, i, window.innerWidth, i]}\n      />\n    )\n  }\n  for (let i = 0; i < window.innerWidth; i=i+gridWidth) {\n    linesB.push(\n      <Line\n        strokeWidth={0.5}\n        stroke={'gray'}\n        points={[i, 0, i, window.innerHeight]}\n      />\n    )\n  }\n  \n\n\n  const handleUndo = () => {\n    console.log('undo')\n    if (historyStep === 0) {\n      return;\n    }\n    historyStep -= 1;\n    const previous = history[historyStep];\n    setLines(previous.lines)\n    setShapes(previous.shapes)\n  }\n\n  const handleRedo = () => {\n    console.log('redo')\n    if (historyStep === history.length - 1) {\n      return;\n    }\n    historyStep += 1;\n    const next = history[historyStep];\n    setLines(next.lines)\n    setShapes(next.shapes)\n  }\n\n  const handleMouseDown = (e) => {\n    if(useTool){\n      isDrawing.current = true;\n      // const transform = e.target.getAbsoluteTransform().copy()\n      // transform.invert()\n      const stage = e.target.getStage()\n      let pos = stage.getPointerPosition();\n      // pos = transform.point(pos)\n      setLines([...lines, { tool, points: [pos.x, pos.y], name: \"line\", x: 0, y: 0, id: uuid() }]);\n      setShapes([...shapes, { tool, points: [pos.x, pos.y], name: \"line\", index: lines.length , x: e.target.x(), y: e.target.y(), id: uuid() }]);\n      \n      setHandleDraw(true)\n    }\n    checkDeselect(e)\n  };\n\n  const handleMouseMove = (e) => {\n    if(useTool){\n      if(handleDraw){\n        // no drawing - skipping\n        if (!isDrawing.current) {\n          return;\n        }\n        const stage = e.target.getStage();\n        const point = stage.getPointerPosition();\n        let lastLine = lines[lines.length - 1];\n        // add point\n        lastLine.points = lastLine.points.concat([point.x, point.y]);\n\n        // replace last\n        lines.splice(lines.length - 1, 1, lastLine);\n        setLines(lines.concat());\n\n        // let lastLine = ''\n        // for(var i=shapes.length-1; i > 0;i--){\n        //   if(shapes[i].name=='line'){\n        //     lastLine = shapes[shapes.length - 1];\n        //   }\n        // }\n\n        // // add point\n        // lastLine.points = lastLine.points.concat([point.x, point.y]);\n\n        // // replace last\n        // shapes.splice(shapes.length - 1, 1, lastLine);\n        // setShapes(shapes.concat());\n        }\n      }\n      \n    \n  };\n\n  const handleMouseUp = () => {\n    if(useTool){\n      isDrawing.current = false;\n      setHandleDraw(false)\n      history = history.slice(0, historyStep + 1);\n      history = history.concat([{shapes: shapes, lines:lines}]);\n      historyStep += 1;\n    }\n    \n  };\n\n  const checkDeselect = (e) => {\n    // deselect when clicked on empty area\n    const clickedOnEmpty = e.target === e.target.getStage();\n    if (clickedOnEmpty) {\n      selectShape(null);\n    }\n    setTextEdit(false)\n  };\n\n  const stageRef = useRef(null);\n  \n  const onDelete = (item) => {\n    setShapes((oldData) => {\n      return (oldData.filter((currentData, index) => {\n        return currentData.id !== item.id;\n      }))\n  })\n  setShapes((prevShape)=>(\n    [...prevShape, item]\n  ))\n  history = history.slice(0, historyStep + 1);\n  history = history.concat([{shapes: [...shapes, item], lines:lines}]);\n  historyStep += 1;\n}\n\n  const onEdit = (e) => {\n    let pos = {}\n    setEditShape((shape)=> ({...shape, text:e.target.value}))\n    setShapes(shapes.map((elem)=>{\n      if(elem.id==selectedId){\n        pos = {...elem, text:e.target.value}\n        return pos\n      }\n      return elem\n    })\n    )\n    history = history.slice(0, historyStep + 1);\n    history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n    historyStep += 1;\n  }\n\n  const handleSave = () => {\n    const data = JSON.stringify([shapes, lines])\n    localStorage.setItem('data', data);\n  }\n\n  useEffect(()=>{\n    const data = JSON.parse(localStorage.getItem('data'));\n    if(data){\n      setLines(data[1])\n      setShapes(data[0])\n      history = [{shapes: data[0], lines:data[1]}];\n      // historyStep += 1;\n    }\n  }, [])\n\n  \n  return (\n    <>\n    <Stage \n        \n        width={window.innerWidth} \n        height={window.innerHeight} \n        ref={stageRef} \n        onTouchStart={(e)=>{checkDeselect(e);handleMouseDown(e)}} \n        onMouseDown={handleMouseDown}\n        onTouchEnd={handleMouseUp}\n        onMousemove={handleMouseMove}\n        onTouchMove={handleMouseMove}\n        onMouseup={handleMouseUp}\n\n      >\n      <Layer>\n        \n        \n       \n        {linesA}\n        {linesB}\n\n\n      {shapes.map((eachShape, i)=> {\n        if(eachShape.name==\"rectangle\"){\n            return(\n              <Rectangle\n              key={i}\n              shapeProps={eachShape}\n              isSelected={eachShape.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(eachShape.id);\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = shapes.slice();\n                rects[i] = newAttrs;\n                setShapes(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: rects, lines:lines}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n            )\n        }\n        else if(eachShape.name==\"circle\"){\n            return(\n              <Circles\n             key={i}\n            shapeProps={eachShape}\n            isSelected={eachShape.id === selectedId}\n            onSelect={() => {\n              setUseTool(false)\n              onDelete(eachShape);\n              selectShape(eachShape.id);\n              \n            }}\n            onMove={()=>onDelete(eachShape)}\n            onChange={(newAttrs) => {\n              const rects = shapes.slice();\n              rects[i] = newAttrs;\n              setShapes(rects);\n              history = history.slice(0, historyStep + 1);\n              history = history.concat([{shapes: rects, lines:lines}]);\n              historyStep += 1;\n            }}\n            useTool={useTool}\n          />\n        )\n        }\n        else if(eachShape.name==\"text\"){\n          return(\n            <Texts\n              key={i}\n              shapeProps={eachShape}\n              isSelected={eachShape.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(eachShape.id);\n                setEditShape(eachShape)\n                setTextEdit(!textEdit)\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = shapes.slice();\n                rects[i] = newAttrs;\n                setShapes(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: rects, lines:lines}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n          )\n        }\n        else if(eachShape.name==\"line\"){\n         \n          return(\n            <Lines\n              key={i}\n              points={lines[eachShape.index].points}\n              tool={lines[eachShape.index].tool}\n              shapeProps={lines[eachShape.index]}\n              isSelected={lines[eachShape.index].id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(lines[eachShape.index].id);\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = lines.slice();\n                rects[eachShape.index] = newAttrs;\n                setLines(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: shapes, lines:rects}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n          )\n         \n        }\n      })\n      }\n      {/* <Line\n             x={200}\n             y={300}\n              points={[100, 100, 200, 200]}\n              stroke=\"#df4b26\"\n              strokeWidth={5}\n              tension={0.5}\n              lineCap=\"round\"\n              globalCompositeOperation={\n                'source-over'\n              }\n            /> */}\n      {/* {lines.map((line, i) => (\n            <Lines\n              key={i}\n              points={line.points}\n              tool={line.tool}\n              shapeProps={line}\n              isSelected={line.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(line);\n                selectShape(line.id);\n                \n              }}\n              onMove={()=>onDelete(line)}\n              onChange={(newAttrs) => {\n                const rects = lines.slice();\n                rects[i] = newAttrs;\n                setLines(rects);\n              }}\n            \n            />\n          ))} */}\n        \n      \n        <Circle\n          name=\"draggableCircle1\"\n          x={50}\n          y={70}\n          radius={25}\n          stroke=\"black\"\n          id=\"circle1\"\n        />\n        <Circle\n          name=\"draggableCircle\"\n          x={50}\n          y={70}\n          radius={25}\n          stroke=\"black\"\n          draggable={!useTool}\n          id=\"circle2\"\n          // onClick={()=>setUseTool(false)}\n          // onTap={()=>setUseTool(false)}\n          // onDragStart={()=>setUseTool(false)}\n          onDragEnd={(e) => {\n            \n            \n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), radius: 25, stroke:\"black\", id: uuid(), fill: \"red\", name:\"circle\" }\n            \n            setShapes((prevCircles) => [\n              ...prevCircles,\n              pos\n            ]);\n            console.log(shapes)\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableCircle = stage.findOne(\".draggableCircle\");\n            draggableCircle.position({ x: 50, y: 70 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n        />\n\n      <Rect\n        x= {25}\n        y= {100}\n        width= {50}\n        height= {50}\n        stroke=\"black\"\n        id= 'rect1'\n      />\n      <Rect\n        name=\"draggableRect\"\n        x= {25}\n        y= {100}\n        width= {50}\n        height= {50}\n        stroke=\"black\"\n        id= 'rect1'\n        draggable={!useTool}\n        \n        // onClick={()=>setUseTool(false)}\n        // onTap={()=>setUseTool(false)}\n        // onDragStart={()=>setUseTool(false)}\n        onDragEnd={(e) => {\n          \n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), stroke:\"black\", width: 50, height: 50, id: uuid(), fill: \"green\", name:\"rectangle\"}\n            setShapes((prevRectangles) => [\n              ...prevRectangles,\n              pos\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableRectangle = stage.findOne(\".draggableRect\");\n            draggableRectangle.position({ x: 25, y: 100 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n      />\n      <Text\n          fontSize={50}\n          text=\"T\"\n          width={40}\n          height={100}\n          x={35}\n          y={160}\n        />\n        <Text\n          name=\"draggableText\"\n          x={35}\n          y={160}\n          text=\"T\"\n          fontSize={50}\n          width={40}\n          height={100}\n          draggable={!useTool}\n          // onClick={()=>setUseTool(false)}\n          // onTap={()=>setUseTool(false)}\n          // onDragStart={()=>setUseTool(false)}\n          onDragEnd={(e) => {\n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), id: uuid(), text: \"T\", width: 40, textEditVisible:true, height:100, fontSize: 50, name:\"text\"}\n            setShapes((prevTexts) => [\n              ...prevTexts,\n              pos\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableText = stage.findOne(\".draggableText\");\n            draggableText.position({ x: 35, y: 160 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n      />\n     <Html>\n        <div>\n        <input type=\"button\" value=\"Undo\" onClick={handleUndo}/>\n        <input type=\"button\" value=\"Redo\" onClick={handleRedo} />\n        <input type=\"button\" value=\"Save\" onClick={handleSave} />\n        <br />\n        <input type=\"button\" value=\"Pencil\" style={tool=='pen' && useTool?{backgroundColor: \"aqua\"}:null} onClick={()=>{setTool('pen'); setUseTool(!useTool)}}/>\n        {/* <input type=\"button\" value=\"Eraser\" style={tool=='eraser' && useTool?{backgroundColor: \"aqua\"}:null} onClick={()=>{setTool('eraser'); setUseTool(!useTool)}} /> */}\n        </div>\n        {textEdit?\n          <textarea value={editShape.text} onChange={onEdit}></textarea>\n          :null\n        }\n     </Html>\n        </Layer>\n    </Stage>\n    \n    \n    </>\n  );\n}\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}