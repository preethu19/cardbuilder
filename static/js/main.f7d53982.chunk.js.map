{"version":3,"sources":["App.js","index.js"],"names":["Rectangle","shapeProps","isSelected","onSelect","onChange","onMove","useTool","shapeRef","React","useRef","trRef","useEffect","current","nodes","getLayer","batchDraw","Fragment","onDblClick","onDblTap","ref","draggable","onDragEnd","e","x","target","y","onTransformEnd","node","scaleX","scaleY","getAbsoluteTransform","getMatrix","console","log","rotation","width","Math","max","height","boundBoxFunc","oldBox","newBox","Circles","radius","Texts","Lines","points","tool","stroke","strokeWidth","tension","lineCap","globalCompositeOperation","newPoints","i","length","concat","history","shapes","lines","historyStep","App","useState","setShapes","selectedId","selectShape","textEdit","setTextEdit","editShape","setEditShape","setTool","setLines","isDrawing","setUseTool","handleDraw","setHandleDraw","scale","stage","setStage","linesA","setLinesA","linesB","setLinesB","gridLines","a","b","gridWidth","window","innerWidth","gridHeight","innerHeight","prevData","handleMouseDown","pos","getStage","getPointerPosition","name","id","uuid","index","checkDeselect","handleMouseMove","point","lastLine","splice","handleMouseUp","slice","stageRef","onDelete","item","oldData","filter","currentData","prevShape","data","JSON","parse","localStorage","getItem","onTouchStart","onMouseDown","onTouchEnd","onMousemove","onTouchMove","onMouseup","onWheel","evt","preventDefault","oldScale","mousePointTo","newScale","deltaY","newX","newY","parseInt","map","eachLine","eachShape","newAttrs","rects","fill","prevCircles","findOne","position","prevRectangles","fontSize","text","textEditVisible","prevTexts","type","value","onClick","previous","next","stringify","setItem","style","backgroundColor","shape","elem","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f7d53982.chunk.js","sourcesContent":["import \"./App.css\";\n\nimport React, { useState, useRef, useEffect } from \"react\";\nimport { Stage, Layer, Circle, Text, Ellipse, Rect, Transformer, Line } from \"react-konva\";\nimport { v4 as uuid } from 'uuid';\nimport { Html } from \"react-konva-utils\";\n\n\nconst Rectangle = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n  return (\n    <React.Fragment>\n      <Rect\n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y(),\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n          const matrix = node.getAbsoluteTransform().getMatrix();\n          console.log(node.rotation())\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            width: Math.max(5, node.width() * scaleX),\n            height: Math.max(node.height() * scaleY),\n            rotation: node.rotation(),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\n\nconst Circles = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  return (\n    <React.Fragment>\n      <Circle\n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y(),\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            radius: Math.max(node.radius() * scaleX, node.radius() * scaleY),\n            rotation: node.rotation(),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.radius < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\nconst Texts = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n  \n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  \n  \n \n\n  return (\n    <React.Fragment>\n      <Text\n       \n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y()\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            \n            width: Math.max(5, node.width() * scaleX),\n            height: Math.max(node.height() * scaleY),\n            rotation: node.rotation(),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\nconst Lines = ({ shapeProps, isSelected, onSelect, onMove, onChange, points, tool, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n  \n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  \n  \n \n\n  return (\n    <React.Fragment>\n    \n      <Line\n       \n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        points={points}\n        stroke=\"#df4b26\"\n        strokeWidth={5}\n        tension={0.5}\n        lineCap=\"round\"\n        draggable={!useTool && isSelected}\n        globalCompositeOperation={\n          tool === 'eraser' ? 'destination-out' : 'source-over'\n        }\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y()\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n          \n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          let newPoints = [];\n          \n          for (let i=0; i<shapeProps.points.length; i=i+2){\n            newPoints = newPoints.concat([shapeProps.points[i]*scaleX, shapeProps.points[i+1]*scaleY]) \n            \n          }\n          onChange({\n            ...shapeProps,\n            // x: node.x(),\n            // y: node.y(),\n            // set minimal value\n            points: newPoints,\n            rotation: node.rotation(),\n            // width: Math.max(5, node.width() * scaleX),\n            // height: Math.max(node.height() * scaleY),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\nlet history = [{shapes: [], lines:[]}]\nlet historyStep = 0;\n\n\n\n\nexport default function App() {\n  const [circles, setCircles] = useState([]);\n  const [rectangles, setRectangles] = useState([]);\n  const [shapes, setShapes] = useState([]);\n  const [selectedId, selectShape] = useState(null);\n  const [textEdit, setTextEdit] = useState(false)\n  const [editShape, setEditShape] = useState(null)\n  const [tool, setTool] = React.useState('');\n  const [lines, setLines] = React.useState([]);\n  const isDrawing = React.useRef(false);\n  const [useTool, setUseTool] = useState(false)\n  const [handleDraw, setHandleDraw] = useState(false)\n  const [stage, setStage] = useState({\n    scale: 1,\n    x: 0,\n    y: 0\n  });\n\n  const handleWheel = (e) => {\n    e.evt.preventDefault();\n\n    const scaleBy = 1.2;\n    const stage = e.target.getStage();\n    const oldScale = stage.scaleX();\n    const mousePointTo = {\n      x: stage.getPointerPosition().x / oldScale - stage.x() / oldScale,\n      y: stage.getPointerPosition().y / oldScale - stage.y() / oldScale\n    };\n\n    const newScale = e.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;\n    const newX = (stage.getPointerPosition().x / newScale - mousePointTo.x) * newScale;\n    const newY = (stage.getPointerPosition().y / newScale - mousePointTo.y) * newScale;\n    // console.log(oldScale, newScale);\n    // console.log(newX, newY)\n    // console.log(e.evt.deltaY)\n    if((newScale<1 || newX>=0 || newY>=0)){\n      setStage({\n        scale: 1,\n        x: 0,\n        y: 0\n      });\n      gridLines(10, 5)\n    }\n    else{\n      setStage({\n        scale: newScale,\n        x: newX,\n        y: newY\n      });\n      gridLines(20*parseInt(newScale), 10*parseInt(newScale))\n    }\n    \n  };\n  \n  const [linesA, setLinesA] = useState([])\n  const [linesB, setLinesB] = useState([])\n  const gridLines = (a, b) => {\n    const gridWidth = window.innerWidth/a\n    const gridHeight = window.innerHeight/b\n    setLinesA([])\n    setLinesB([])\n\n      for (let i = 0; i < window.innerHeight; i=i+gridHeight) {\n        setLinesA((prevData)=>(\n          [...prevData, [0, i, window.innerWidth, i] ]\n        )\n        )\n      }\n      for (let i = 0; i < window.innerWidth; i=i+gridWidth) {\n        setLinesB((prevData)=>(\n          [...prevData, [i, 0, i, window.innerHeight]]\n        )\n        )\n  }\n\n}\n\n\n  const handleUndo = () => {\n    console.log('undo')\n    if (historyStep === 0) {\n      return;\n    }\n    historyStep -= 1;\n    const previous = history[historyStep];\n    setLines(previous.lines)\n    setShapes(previous.shapes)\n  }\n\n  const handleRedo = () => {\n    console.log('redo')\n    if (historyStep === history.length - 1) {\n      return;\n    }\n    historyStep += 1;\n    const next = history[historyStep];\n    setLines(next.lines)\n    setShapes(next.shapes)\n  }\n\n  const handleMouseDown = (e) => {\n    if(useTool){\n      isDrawing.current = true;\n      // const transform = e.target.getAbsoluteTransform().copy()\n      // transform.invert()\n      const stage = e.target.getStage()\n      let pos = stage.getPointerPosition();\n      // pos = transform.point(pos)\n      setLines([...lines, { tool, points: [pos.x, pos.y], name: \"line\", x: 0, y: 0, id: uuid() }]);\n      setShapes([...shapes, { tool, points: [pos.x, pos.y], name: \"line\", index: lines.length , x: e.target.x(), y: e.target.y(), id: uuid() }]);\n      \n      setHandleDraw(true)\n    }\n    checkDeselect(e)\n  };\n\n  const handleMouseMove = (e) => {\n    if(useTool){\n      if(handleDraw){\n        // no drawing - skipping\n        if (!isDrawing.current) {\n          return;\n        }\n        const stage = e.target.getStage();\n        const point = stage.getPointerPosition();\n        let lastLine = lines[lines.length - 1];\n        // add point\n        lastLine.points = lastLine.points.concat([point.x, point.y]);\n\n        // replace last\n        lines.splice(lines.length - 1, 1, lastLine);\n        setLines(lines.concat());\n\n        // let lastLine = ''\n        // for(var i=shapes.length-1; i > 0;i--){\n        //   if(shapes[i].name=='line'){\n        //     lastLine = shapes[shapes.length - 1];\n        //   }\n        // }\n\n        // // add point\n        // lastLine.points = lastLine.points.concat([point.x, point.y]);\n\n        // // replace last\n        // shapes.splice(shapes.length - 1, 1, lastLine);\n        // setShapes(shapes.concat());\n        }\n      }\n      \n    \n  };\n\n  const handleMouseUp = () => {\n    if(useTool){\n      isDrawing.current = false;\n      setHandleDraw(false)\n      history = history.slice(0, historyStep + 1);\n      history = history.concat([{shapes: shapes, lines:lines}]);\n      historyStep += 1;\n    }\n    \n  };\n\n  const checkDeselect = (e) => {\n    // deselect when clicked on empty area\n    const clickedOnEmpty = e.target === e.target.getStage();\n    if (clickedOnEmpty) {\n      selectShape(null);\n    }\n    setTextEdit(false)\n  };\n\n  const stageRef = useRef(null);\n  \n  const onDelete = (item) => {\n    setShapes((oldData) => {\n      return (oldData.filter((currentData, index) => {\n        return currentData.id !== item.id;\n      }))\n  })\n  setShapes((prevShape)=>(\n    [...prevShape, item]\n  ))\n  history = history.slice(0, historyStep + 1);\n  history = history.concat([{shapes: [...shapes, item], lines:lines}]);\n  historyStep += 1;\n}\n\n  const onEdit = (e) => {\n    let pos = {}\n    setEditShape((shape)=> ({...shape, text:e.target.value}))\n    setShapes(shapes.map((elem)=>{\n      if(elem.id==selectedId){\n        pos = {...elem, text:e.target.value}\n        return pos\n      }\n      return elem\n    })\n    )\n    history = history.slice(0, historyStep + 1);\n    history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n    historyStep += 1;\n  }\n\n  const handleSave = () => {\n    const data = JSON.stringify([shapes, lines])\n    localStorage.setItem('data', data);\n  }\n\n  useEffect(()=>{\n    const data = JSON.parse(localStorage.getItem('data'));\n    if(data){\n      setLines(data[1])\n      setShapes(data[0])\n      history = [{shapes: data[0], lines:data[1]}];\n      // historyStep += 1;\n    }\n    gridLines(10, 5)\n  }, [])\n\n  \n  return (\n    <>\n    <Stage \n        \n        width={window.innerWidth} \n        height={window.innerHeight} \n        ref={stageRef} \n        onTouchStart={(e)=>{checkDeselect(e);handleMouseDown(e)}} \n        onMouseDown={handleMouseDown}\n        onTouchEnd={handleMouseUp}\n        onMousemove={handleMouseMove}\n        onTouchMove={handleMouseMove}\n        onMouseup={handleMouseUp}\n        onWheel={handleWheel}\n      scaleX={stage.scale}\n      scaleY={stage.scale}\n      x={stage.x}\n      y={stage.y}\n      >\n      <Layer>\n        \n        \n       \n        {linesA.map((eachLine, i)=>{\n          return (\n            <Line\n            key={i}\n            strokeWidth={1}\n            stroke={'gray'}\n            points={eachLine}\n          />\n          )\n        })}\n        {linesB.map((eachLine, i)=>{\n          return (\n            <Line\n            key={i}\n            strokeWidth={1}\n            stroke={'gray'}\n            points={eachLine}\n          />\n          )\n        })}\n\n\n      {shapes.map((eachShape, i)=> {\n        if(eachShape.name==\"rectangle\"){\n            return(\n              <Rectangle\n              key={i}\n              shapeProps={eachShape}\n              isSelected={eachShape.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(eachShape.id);\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = shapes.slice();\n                rects[i] = newAttrs;\n                setShapes(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: rects, lines:lines}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n            )\n        }\n        else if(eachShape.name==\"circle\"){\n            return(\n              <Circles\n             key={i}\n            shapeProps={eachShape}\n            isSelected={eachShape.id === selectedId}\n            onSelect={() => {\n              setUseTool(false)\n              onDelete(eachShape);\n              selectShape(eachShape.id);\n              \n            }}\n            onMove={()=>onDelete(eachShape)}\n            onChange={(newAttrs) => {\n              const rects = shapes.slice();\n              rects[i] = newAttrs;\n              setShapes(rects);\n              history = history.slice(0, historyStep + 1);\n              history = history.concat([{shapes: rects, lines:lines}]);\n              historyStep += 1;\n            }}\n            useTool={useTool}\n          />\n        )\n        }\n        else if(eachShape.name==\"text\"){\n          return(\n            <Texts\n              key={i}\n              shapeProps={eachShape}\n              isSelected={eachShape.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(eachShape.id);\n                setEditShape(eachShape)\n                setTextEdit(!textEdit)\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = shapes.slice();\n                rects[i] = newAttrs;\n                setShapes(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: rects, lines:lines}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n          )\n        }\n        else if(eachShape.name==\"line\"){\n         \n          return(\n            <Lines\n              key={i}\n              points={lines[eachShape.index].points}\n              tool={lines[eachShape.index].tool}\n              shapeProps={lines[eachShape.index]}\n              isSelected={lines[eachShape.index].id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(lines[eachShape.index].id);\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = lines.slice();\n                rects[eachShape.index] = newAttrs;\n                setLines(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: shapes, lines:rects}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n          )\n         \n        }\n      })\n      }\n      {/* <Line\n             x={200}\n             y={300}\n              points={[100, 100, 200, 200]}\n              stroke=\"#df4b26\"\n              strokeWidth={5}\n              tension={0.5}\n              lineCap=\"round\"\n              globalCompositeOperation={\n                'source-over'\n              }\n            /> */}\n      {/* {lines.map((line, i) => (\n            <Lines\n              key={i}\n              points={line.points}\n              tool={line.tool}\n              shapeProps={line}\n              isSelected={line.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(line);\n                selectShape(line.id);\n                \n              }}\n              onMove={()=>onDelete(line)}\n              onChange={(newAttrs) => {\n                const rects = lines.slice();\n                rects[i] = newAttrs;\n                setLines(rects);\n              }}\n            \n            />\n          ))} */}\n        \n      \n        <Circle\n          name=\"draggableCircle1\"\n          x={50}\n          y={70}\n          radius={25}\n          stroke=\"black\"\n          id=\"circle1\"\n        />\n        <Circle\n          name=\"draggableCircle\"\n          x={50}\n          y={70}\n          radius={25}\n          stroke=\"black\"\n          draggable={!useTool}\n          id=\"circle2\"\n          // onClick={()=>setUseTool(false)}\n          // onTap={()=>setUseTool(false)}\n          // onDragStart={()=>setUseTool(false)}\n          onDragEnd={(e) => {\n            \n            \n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), radius: 25, stroke:\"black\", id: uuid(), fill: \"red\", name:\"circle\" }\n            \n            setShapes((prevCircles) => [\n              ...prevCircles,\n              pos\n            ]);\n            console.log(shapes)\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableCircle = stage.findOne(\".draggableCircle\");\n            draggableCircle.position({ x: 50, y: 70 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n        />\n\n      <Rect\n        x= {25}\n        y= {100}\n        width= {50}\n        height= {50}\n        stroke=\"black\"\n        id= 'rect1'\n      />\n      <Rect\n        name=\"draggableRect\"\n        x= {25}\n        y= {100}\n        width= {50}\n        height= {50}\n        stroke=\"black\"\n        id= 'rect1'\n        draggable={!useTool}\n        \n        // onClick={()=>setUseTool(false)}\n        // onTap={()=>setUseTool(false)}\n        // onDragStart={()=>setUseTool(false)}\n        onDragEnd={(e) => {\n          \n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), stroke:\"black\", width: 50, height: 50, id: uuid(), fill: \"green\", name:\"rectangle\"}\n            setShapes((prevRectangles) => [\n              ...prevRectangles,\n              pos\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableRectangle = stage.findOne(\".draggableRect\");\n            draggableRectangle.position({ x: 25, y: 100 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n      />\n      <Text\n          fontSize={50}\n          text=\"T\"\n          width={40}\n          height={100}\n          x={35}\n          y={160}\n        />\n        <Text\n          name=\"draggableText\"\n          x={35}\n          y={160}\n          text=\"T\"\n          fontSize={50}\n          width={40}\n          height={100}\n          draggable={!useTool}\n          // onClick={()=>setUseTool(false)}\n          // onTap={()=>setUseTool(false)}\n          // onDragStart={()=>setUseTool(false)}\n          onDragEnd={(e) => {\n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), id: uuid(), text: \"T\", width: 40, textEditVisible:true, height:100, fontSize: 50, name:\"text\"}\n            setShapes((prevTexts) => [\n              ...prevTexts,\n              pos\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableText = stage.findOne(\".draggableText\");\n            draggableText.position({ x: 35, y: 160 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n      />\n     <Html>\n        <div>\n        <input type=\"button\" value=\"Undo\" onClick={handleUndo}/>\n        <input type=\"button\" value=\"Redo\" onClick={handleRedo} />\n        <input type=\"button\" value=\"Save\" onClick={handleSave} />\n        <br />\n        <input type=\"button\" value=\"Pencil\" style={tool=='pen' && useTool?{backgroundColor: \"aqua\"}:null} onClick={()=>{setTool('pen'); setUseTool(!useTool)}}/>\n        {/* <input type=\"button\" value=\"Eraser\" style={tool=='eraser' && useTool?{backgroundColor: \"aqua\"}:null} onClick={()=>{setTool('eraser'); setUseTool(!useTool)}} /> */}\n        </div>\n        {textEdit?\n          <textarea value={editShape.text} onChange={onEdit}></textarea>\n          :null\n        }\n     </Html>\n        </Layer>\n    </Stage>\n    \n    \n    </>\n  );\n}\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}