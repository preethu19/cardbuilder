{"version":3,"sources":["App.js","index.js"],"names":["Rectangle","shapeProps","isSelected","onSelect","onChange","onMove","useTool","shapeRef","React","useRef","trRef","useEffect","current","nodes","getLayer","batchDraw","Fragment","onDblClick","onDblTap","ref","draggable","onDragEnd","e","x","target","y","onTransformEnd","node","scaleX","scaleY","getAbsoluteTransform","getMatrix","console","log","rotation","width","Math","max","height","boundBoxFunc","oldBox","newBox","Circles","radius","Texts","Lines","points","tool","stroke","strokeWidth","tension","lineCap","globalCompositeOperation","newPoints","i","length","concat","history","shapes","lines","historyStep","App","useState","setShapes","selectedId","selectShape","textEdit","setTextEdit","editShape","setEditShape","setTool","setLines","isDrawing","setUseTool","handleDraw","setHandleDraw","gridWidth","window","innerWidth","gridHeight","innerHeight","linesA","linesB","push","handleMouseDown","pos","getStage","getPointerPosition","name","id","uuid","index","checkDeselect","handleMouseMove","point","lastLine","splice","handleMouseUp","slice","stageRef","onDelete","item","oldData","filter","currentData","prevShape","data","JSON","parse","localStorage","getItem","onTouchStart","onMouseDown","onTouchEnd","onMousemove","onTouchMove","onMouseup","map","eachShape","newAttrs","rects","fill","prevCircles","findOne","position","prevRectangles","fontSize","text","textEditVisible","prevTexts","type","value","onClick","previous","next","stringify","setItem","style","backgroundColor","shape","elem","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"uOAQMA,EAAY,SAAC,GAAqE,IAAnEC,EAAkE,EAAlEA,WAAYC,EAAsD,EAAtDA,WAAYC,EAA0C,EAA1CA,SAAkBC,GAAwB,EAAhCC,OAAgC,EAAxBD,UAAUE,EAAc,EAAdA,QACjEC,EAAWC,IAAMC,SACjBC,EAAQF,IAAMC,SASpB,OAPAD,IAAMG,WAAU,WACVT,IAEFQ,EAAME,QAAQC,MAAM,CAACN,EAASK,UAC9BF,EAAME,QAAQE,WAAWC,eAE1B,CAACb,IAEF,eAAC,IAAMc,SAAP,WACE,cAAC,IAAD,yBACEC,WAAYd,EACZe,SAAUf,EACVgB,IAAKZ,GACDN,GAJN,IAKEmB,WAAYd,GAAWJ,EAGvBmB,UAAW,SAACC,GAEVlB,EAAS,2BACJH,GADG,IAENsB,EAAGD,EAAEE,OAAOD,IACZE,EAAGH,EAAEE,OAAOC,QAGhBC,eAAgB,SAACJ,GAKf,IAAMK,EAAOpB,EAASK,QAChBgB,EAASD,EAAKC,SACdC,EAASF,EAAKE,SACLF,EAAKG,uBAAuBC,YAC3CC,QAAQC,IAAIN,EAAKO,YAEjBP,EAAKC,OAAO,GACZD,EAAKE,OAAO,GACZzB,EAAS,2BACJH,GADG,IAENsB,EAAGI,EAAKJ,IACRE,EAAGE,EAAKF,IAERU,MAAOC,KAAKC,IAAI,EAAGV,EAAKQ,QAAUP,GAClCU,OAAQF,KAAKC,IAAIV,EAAKW,SAAWT,GACjCK,SAAUP,EAAKO,kBAIpBhC,GACC,cAAC,IAAD,CACEiB,IAAKT,EACL6B,aAAc,SAACC,EAAQC,GAErB,OAAIA,EAAON,MAAQ,GAAKM,EAAOH,OAAS,EAC/BE,EAEFC,SAUbC,EAAU,SAAC,GAAqE,IAAnEzC,EAAkE,EAAlEA,WAAYC,EAAsD,EAAtDA,WAAYC,EAA0C,EAA1CA,SAAkBC,GAAwB,EAAhCC,OAAgC,EAAxBD,UAAUE,EAAc,EAAdA,QAC/DC,EAAWC,IAAMC,SACjBC,EAAQF,IAAMC,SAUpB,OARAD,IAAMG,WAAU,WACVT,IAEFQ,EAAME,QAAQC,MAAM,CAACN,EAASK,UAC9BF,EAAME,QAAQE,WAAWC,eAE1B,CAACb,IAGF,eAAC,IAAMc,SAAP,WACE,cAAC,IAAD,yBACEC,WAAYd,EACZe,SAAUf,EACVgB,IAAKZ,GACDN,GAJN,IAKEmB,WAAYd,GAAWJ,EAGvBmB,UAAW,SAACC,GAEVlB,EAAS,2BACJH,GADG,IAENsB,EAAGD,EAAEE,OAAOD,IACZE,EAAGH,EAAEE,OAAOC,QAGhBC,eAAgB,SAACJ,GAKf,IAAMK,EAAOpB,EAASK,QAChBgB,EAASD,EAAKC,SACdC,EAASF,EAAKE,SAGpBF,EAAKC,OAAO,GACZD,EAAKE,OAAO,GACZzB,EAAS,2BACJH,GADG,IAENsB,EAAGI,EAAKJ,IACRE,EAAGE,EAAKF,IAERkB,OAAQP,KAAKC,IAAIV,EAAKgB,SAAWf,EAAQD,EAAKgB,SAAWd,GACzDK,SAAUP,EAAKO,kBAIpBhC,GACC,cAAC,IAAD,CACEiB,IAAKT,EACL6B,aAAc,SAACC,EAAQC,GAErB,OAAIA,EAAOE,OAAS,EACXH,EAEFC,SAQbG,EAAQ,SAAC,GAAqE,IAAnE3C,EAAkE,EAAlEA,WAAYC,EAAsD,EAAtDA,WAAYC,EAA0C,EAA1CA,SAAkBC,GAAwB,EAAhCC,OAAgC,EAAxBD,UAAUE,EAAc,EAAdA,QAC7DC,EAAWC,IAAMC,SACjBC,EAAQF,IAAMC,SAcpB,OAZAD,IAAMG,WAAU,WACVT,IAEFQ,EAAME,QAAQC,MAAM,CAACN,EAASK,UAC9BF,EAAME,QAAQE,WAAWC,eAE1B,CAACb,IAOF,eAAC,IAAMc,SAAP,WACE,cAAC,IAAD,yBAEEC,WAAYd,EACZe,SAAUf,EACVgB,IAAKZ,GACDN,GALN,IAMEmB,WAAYd,GAAWJ,EAGvBmB,UAAW,SAACC,GAEVlB,EAAS,2BACJH,GADG,IAENsB,EAAGD,EAAEE,OAAOD,IACZE,EAAGH,EAAEE,OAAOC,QAGhBC,eAAgB,SAACJ,GAKf,IAAMK,EAAOpB,EAASK,QAChBgB,EAASD,EAAKC,SACdC,EAASF,EAAKE,SAGpBF,EAAKC,OAAO,GACZD,EAAKE,OAAO,GACZzB,EAAS,2BACJH,GADG,IAENsB,EAAGI,EAAKJ,IACRE,EAAGE,EAAKF,IAGRU,MAAOC,KAAKC,IAAI,EAAGV,EAAKQ,QAAUP,GAClCU,OAAQF,KAAKC,IAAIV,EAAKW,SAAWT,GACjCK,SAAUP,EAAKO,kBAIpBhC,GACC,cAAC,IAAD,CACEiB,IAAKT,EACL6B,aAAc,SAACC,EAAQC,GAErB,OAAIA,EAAON,MAAQ,GAAKM,EAAOH,OAAS,EAC/BE,EAEFC,SASbI,EAAQ,SAAC,GAAmF,IAAjF5C,EAAgF,EAAhFA,WAAYC,EAAoE,EAApEA,WAAYC,EAAwD,EAAxDA,SAAkBC,GAAsC,EAA9CC,OAA8C,EAAtCD,UAAU0C,EAA4B,EAA5BA,OAAQC,EAAoB,EAApBA,KAAMzC,EAAc,EAAdA,QAC3EC,EAAWC,IAAMC,SACjBC,EAAQF,IAAMC,SAcpB,OAZAD,IAAMG,WAAU,WACVT,IAEFQ,EAAME,QAAQC,MAAM,CAACN,EAASK,UAC9BF,EAAME,QAAQE,WAAWC,eAE1B,CAACb,IAOF,eAAC,IAAMc,SAAP,WAEE,cAAC,IAAD,yBAEEC,WAAYd,EACZe,SAAUf,EACVgB,IAAKZ,GACDN,GALN,IAME6C,OAAQA,EACRE,OAAO,UACPC,YAAa,EACbC,QAAS,GACTC,QAAQ,QACR/B,WAAYd,GAAWJ,EACvBkD,yBACW,WAATL,EAAoB,kBAAoB,cAI1C1B,UAAW,SAACC,GAEVlB,EAAS,2BACJH,GADG,IAENsB,EAAGD,EAAEE,OAAOD,IACZE,EAAGH,EAAEE,OAAOC,QAGhBC,eAAgB,SAACJ,GAKf,IAAMK,EAAOpB,EAASK,QAChBgB,EAASD,EAAKC,SACdC,EAASF,EAAKE,SAGpBF,EAAKC,OAAO,GACZD,EAAKE,OAAO,GAGZ,IAFA,IAAIwB,EAAY,GAEPC,EAAE,EAAGA,EAAErD,EAAW6C,OAAOS,OAAQD,GAAI,EAC5CD,EAAYA,EAAUG,OAAO,CAACvD,EAAW6C,OAAOQ,GAAG1B,EAAQ3B,EAAW6C,OAAOQ,EAAE,GAAGzB,IAGpFzB,EAAS,2BACJH,GADG,IAKN6C,OAAQO,EACRnB,SAAUP,EAAKO,kBAMpBhC,GACC,cAAC,IAAD,CACEiB,IAAKT,EACL6B,aAAc,SAACC,EAAQC,GAErB,OAAIA,EAAON,MAAQ,GAAKM,EAAOH,OAAS,EAC/BE,EAEFC,SASfgB,EAAU,CAAC,CAACC,OAAQ,GAAIC,MAAM,KAC9BC,EAAc,EAKH,SAASC,IAoBtB,IApB6B,IAAD,EACEC,mBAAS,IADX,gCAEQA,mBAAS,KAFjB,gCAGAA,mBAAS,KAHT,mBAGrBJ,EAHqB,KAGbK,EAHa,OAIMD,mBAAS,MAJf,mBAIrBE,EAJqB,KAITC,EAJS,OAKIH,oBAAS,GALb,mBAKrBI,EALqB,KAKXC,EALW,OAMML,mBAAS,MANf,mBAMrBM,EANqB,KAMVC,EANU,OAOJ7D,IAAMsD,SAAS,IAPX,mBAOrBf,EAPqB,KAOfuB,EAPe,OAQF9D,IAAMsD,SAAS,IARb,mBAQrBH,EARqB,KAQdY,EARc,KAStBC,EAAYhE,IAAMC,QAAO,GATH,EAUEqD,oBAAS,GAVX,mBAUrBxD,EAVqB,KAUZmE,EAVY,OAWQX,oBAAS,GAXjB,mBAWrBY,EAXqB,KAWTC,EAXS,KAcxBC,EAAYC,OAAOC,WAAW,GAC9BC,EAAaF,OAAOG,YAAY,EAEhCC,GAAS,GACTC,GAAS,GAEJ5B,GAAI,EAAGA,GAAIuB,OAAOG,YAAa1B,IAAIyB,EAC1CE,GAAOE,KACL,cAAC,IAAD,CACElC,YAAa,GACbD,OAAQ,OACRF,OAAQ,CAAC,EAAGQ,GAAGuB,OAAOC,WAAYxB,OAIxC,IAAK,IAAIA,GAAI,EAAGA,GAAIuB,OAAOC,WAAYxB,IAAIsB,EACzCM,GAAOC,KACL,cAAC,IAAD,CACElC,YAAa,GACbD,OAAQ,OACRF,OAAQ,CAACQ,GAAG,EAAGA,GAAGuB,OAAOG,gBAO/B,IAsBMI,GAAkB,SAAC9D,GACvB,GAAGhB,EAAQ,CACTkE,EAAU5D,SAAU,EAGpB,IACIyE,EADU/D,EAAEE,OAAO8D,WACPC,qBAEhBhB,EAAS,GAAD,mBAAKZ,GAAL,CAAY,CAAEZ,OAAMD,OAAQ,CAACuC,EAAI9D,EAAG8D,EAAI5D,GAAI+D,KAAM,OAAQjE,EAAG,EAAGE,EAAG,EAAGgE,GAAIC,mBAClF3B,EAAU,GAAD,mBAAKL,GAAL,CAAa,CAAEX,OAAMD,OAAQ,CAACuC,EAAI9D,EAAG8D,EAAI5D,GAAI+D,KAAM,OAAQG,MAAOhC,EAAMJ,OAAShC,EAAGD,EAAEE,OAAOD,IAAKE,EAAGH,EAAEE,OAAOC,IAAKgE,GAAIC,mBAEhIf,GAAc,GAEhBiB,GAActE,IAGVuE,GAAkB,SAACvE,GACvB,GAAGhB,GACEoE,EAAW,CAEZ,IAAKF,EAAU5D,QACb,OAEF,IACMkF,EADQxE,EAAEE,OAAO8D,WACHC,qBAChBQ,EAAWpC,EAAMA,EAAMJ,OAAS,GAEpCwC,EAASjD,OAASiD,EAASjD,OAAOU,OAAO,CAACsC,EAAMvE,EAAGuE,EAAMrE,IAGzDkC,EAAMqC,OAAOrC,EAAMJ,OAAS,EAAG,EAAGwC,GAClCxB,EAASZ,EAAMH,YAqBfyC,GAAgB,WACjB3F,IACDkE,EAAU5D,SAAU,EACpB+D,GAAc,GAEdlB,GADAA,EAAUA,EAAQyC,MAAM,EAAGtC,EAAc,IACvBJ,OAAO,CAAC,CAACE,OAAQA,EAAQC,MAAMA,KACjDC,GAAe,IAKbgC,GAAgB,SAACtE,GAEEA,EAAEE,SAAWF,EAAEE,OAAO8D,YAE3CrB,EAAY,MAEdE,GAAY,IAGRgC,GAAW1F,iBAAO,MAElB2F,GAAW,SAACC,GAChBtC,GAAU,SAACuC,GACT,OAAQA,EAAQC,QAAO,SAACC,EAAab,GACnC,OAAOa,EAAYf,KAAOY,EAAKZ,SAGrC1B,GAAU,SAAC0C,GAAD,4BACJA,GADI,CACOJ,OAGjB5C,GADAA,EAAUA,EAAQyC,MAAM,EAAGtC,EAAc,IACvBJ,OAAO,CAAC,CAACE,OAAO,GAAD,mBAAMA,GAAN,CAAc2C,IAAO1C,MAAMA,KAC5DC,GAAe,GAmCf,OAXAjD,qBAAU,WACR,IAAM+F,EAAOC,KAAKC,MAAMC,aAAaC,QAAQ,SAC1CJ,IACDnC,EAASmC,EAAK,IACd3C,EAAU2C,EAAK,IACfjD,EAAU,CAAC,CAACC,OAAQgD,EAAK,GAAI/C,MAAM+C,EAAK,QAGzC,IAID,mCACA,cAAC,IAAD,CAEIvE,MAAO0C,OAAOC,WACdxC,OAAQuC,OAAOG,YACf7D,IAAKgF,GACLY,aAAc,SAACzF,GAAKsE,GAActE,GAAG8D,GAAgB9D,IACrD0F,YAAa5B,GACb6B,WAAYhB,GACZiB,YAAarB,GACbsB,YAAatB,GACbuB,UAAWnB,GAVf,SAaE,eAAC,IAAD,WAIGhB,GACAC,GAGFxB,EAAO2D,KAAI,SAACC,EAAWhE,GACtB,MAAmB,aAAhBgE,EAAU9B,KAEP,cAAC,EAAD,CAEAvF,WAAYqH,EACZpH,WAAYoH,EAAU7B,KAAOzB,EAC7B7D,SAAU,WACRsE,GAAW,GACX2B,GAASkB,GACTrD,EAAYqD,EAAU7B,KAGxBpF,OAAQ,kBAAI+F,GAASkB,IACrBlH,SAAU,SAACmH,GACT,IAAMC,EAAQ9D,EAAOwC,QACrBsB,EAAMlE,GAAKiE,EACXxD,EAAUyD,GAEV/D,GADAA,EAAUA,EAAQyC,MAAM,EAAGtC,EAAc,IACvBJ,OAAO,CAAC,CAACE,OAAQ8D,EAAO7D,MAAMA,KAChDC,GAAe,GAEjBtD,QAASA,GAlBJgD,GAsBa,UAAhBgE,EAAU9B,KAEZ,cAAC,EAAD,CAEFvF,WAAYqH,EACZpH,WAAYoH,EAAU7B,KAAOzB,EAC7B7D,SAAU,WACRsE,GAAW,GACX2B,GAASkB,GACTrD,EAAYqD,EAAU7B,KAGxBpF,OAAQ,kBAAI+F,GAASkB,IACrBlH,SAAU,SAACmH,GACT,IAAMC,EAAQ9D,EAAOwC,QACrBsB,EAAMlE,GAAKiE,EACXxD,EAAUyD,GAEV/D,GADAA,EAAUA,EAAQyC,MAAM,EAAGtC,EAAc,IACvBJ,OAAO,CAAC,CAACE,OAAQ8D,EAAO7D,MAAMA,KAChDC,GAAe,GAEjBtD,QAASA,GAlBHgD,GAsBc,QAAhBgE,EAAU9B,KAEd,cAAC,EAAD,CAEEvF,WAAYqH,EACZpH,WAAYoH,EAAU7B,KAAOzB,EAC7B7D,SAAU,WACRsE,GAAW,GACX2B,GAASkB,GACTrD,EAAYqD,EAAU7B,IACtBpB,EAAaiD,GACbnD,GAAaD,IAGf7D,OAAQ,kBAAI+F,GAASkB,IACrBlH,SAAU,SAACmH,GACT,IAAMC,EAAQ9D,EAAOwC,QACrBsB,EAAMlE,GAAKiE,EACXxD,EAAUyD,GAEV/D,GADAA,EAAUA,EAAQyC,MAAM,EAAGtC,EAAc,IACvBJ,OAAO,CAAC,CAACE,OAAQ8D,EAAO7D,MAAMA,KAChDC,GAAe,GAEjBtD,QAASA,GApBJgD,GAwBa,QAAhBgE,EAAU9B,KAGd,cAAC,EAAD,CAEE1C,OAAQa,EAAM2D,EAAU3B,OAAO7C,OAC/BC,KAAMY,EAAM2D,EAAU3B,OAAO5C,KAC7B9C,WAAY0D,EAAM2D,EAAU3B,OAC5BzF,WAAYyD,EAAM2D,EAAU3B,OAAOF,KAAOzB,EAC1C7D,SAAU,WACRsE,GAAW,GACX2B,GAASkB,GACTrD,EAAYN,EAAM2D,EAAU3B,OAAOF,KAGrCpF,OAAQ,kBAAI+F,GAASkB,IACrBlH,SAAU,SAACmH,GACT,IAAMC,EAAQ7D,EAAMuC,QACpBsB,EAAMF,EAAU3B,OAAS4B,EACzBhD,EAASiD,GAET/D,GADAA,EAAUA,EAAQyC,MAAM,EAAGtC,EAAc,IACvBJ,OAAO,CAAC,CAACE,OAAQA,EAAQC,MAAM6D,KACjD5D,GAAe,GAEjBtD,QAASA,GApBJgD,QAJN,KAmEL,cAAC,IAAD,CACEkC,KAAK,mBACLjE,EAAG,GACHE,EAAG,GACHkB,OAAQ,GACRK,OAAO,QACPyC,GAAG,YAEL,cAAC,IAAD,CACED,KAAK,kBACLjE,EAAG,GACHE,EAAG,GACHkB,OAAQ,GACRK,OAAO,QACP5B,WAAYd,EACZmF,GAAG,UAIHpE,UAAW,SAACC,GAMV,IAAM+D,EAAM,CAAE9D,EAAGD,EAAEE,OAAOD,IAAKE,EAAGH,EAAEE,OAAOC,IAAKkB,OAAQ,GAAIK,OAAO,QAASyC,GAAIC,eAAQ+B,KAAM,MAAOjC,KAAK,UAE1GzB,GAAU,SAAC2D,GAAD,4BACLA,GADK,CAERrC,OAEFrD,QAAQC,IAAIyB,GAGAyC,GAASvF,QACO+G,QAAQ,oBACpBC,SAAS,CAAErG,EAAG,GAAIE,EAAG,KAErCgC,GADAA,EAAUA,EAAQyC,MAAM,EAAGtC,EAAc,IACvBJ,OAAO,CAAC,CAACE,OAAO,GAAD,mBAAMA,GAAN,CAAc2B,IAAM1B,MAAMA,KAC3DC,GAAe,KAIrB,cAAC,IAAD,CACErC,EAAI,GACJE,EAAI,IACJU,MAAQ,GACRG,OAAS,GACTU,OAAO,QACPyC,GAAI,UAEN,cAAC,IAAD,CACED,KAAK,gBACLjE,EAAI,GACJE,EAAI,IACJU,MAAQ,GACRG,OAAS,GACTU,OAAO,QACPyC,GAAI,QACJrE,WAAYd,EAKZe,UAAW,SAACC,GAKR,IAAM+D,EAAM,CAAE9D,EAAGD,EAAEE,OAAOD,IAAKE,EAAGH,EAAEE,OAAOC,IAAKuB,OAAO,QAASb,MAAO,GAAIG,OAAQ,GAAImD,GAAIC,eAAQ+B,KAAM,QAASjC,KAAK,aACvHzB,GAAU,SAAC8D,GAAD,4BACLA,GADK,CAERxC,OAKUc,GAASvF,QACU+G,QAAQ,kBACpBC,SAAS,CAAErG,EAAG,GAAIE,EAAG,MAExCgC,GADAA,EAAUA,EAAQyC,MAAM,EAAGtC,EAAc,IACvBJ,OAAO,CAAC,CAACE,OAAO,GAAD,mBAAMA,GAAN,CAAc2B,IAAM1B,MAAMA,KAC3DC,GAAe,KAGrB,cAAC,IAAD,CACIkE,SAAU,GACVC,KAAK,IACL5F,MAAO,GACPG,OAAQ,IACRf,EAAG,GACHE,EAAG,MAEL,cAAC,IAAD,CACE+D,KAAK,gBACLjE,EAAG,GACHE,EAAG,IACHsG,KAAK,IACLD,SAAU,GACV3F,MAAO,GACPG,OAAQ,IACRlB,WAAYd,EAIZe,UAAW,SAACC,GAIV,IAAM+D,EAAM,CAAE9D,EAAGD,EAAEE,OAAOD,IAAKE,EAAGH,EAAEE,OAAOC,IAAKgE,GAAIC,eAAQqC,KAAM,IAAK5F,MAAO,GAAI6F,iBAAgB,EAAM1F,OAAO,IAAKwF,SAAU,GAAItC,KAAK,QACvIzB,GAAU,SAACkE,GAAD,4BACLA,GADK,CAER5C,OAKUc,GAASvF,QACK+G,QAAQ,kBACpBC,SAAS,CAAErG,EAAG,GAAIE,EAAG,MAEnCgC,GADAA,EAAUA,EAAQyC,MAAM,EAAGtC,EAAc,IACvBJ,OAAO,CAAC,CAACE,OAAO,GAAD,mBAAMA,GAAN,CAAc2B,IAAM1B,MAAMA,KAC3DC,GAAe,KAGtB,eAAC,IAAD,WACG,gCACA,uBAAOsE,KAAK,SAASC,MAAM,OAAOC,QArbrB,WAEjB,GADApG,QAAQC,IAAI,QACQ,IAAhB2B,EAAJ,CAIA,IAAMyE,EAAW5E,EADjBG,GAAe,GAEfW,EAAS8D,EAAS1E,OAClBI,EAAUsE,EAAS3E,YA8af,uBAAOwE,KAAK,SAASC,MAAM,OAAOC,QA3arB,WAEjB,GADApG,QAAQC,IAAI,QACR2B,IAAgBH,EAAQF,OAAS,EAArC,CAIA,IAAM+E,EAAO7E,EADbG,GAAe,GAEfW,EAAS+D,EAAK3E,OACdI,EAAUuE,EAAK5E,YAoaX,uBAAOwE,KAAK,SAASC,MAAM,OAAOC,QAzTrB,WACjB,IAAM1B,EAAOC,KAAK4B,UAAU,CAAC7E,EAAQC,IACrCkD,aAAa2B,QAAQ,OAAQ9B,MAwTzB,uBACA,uBAAOwB,KAAK,SAASC,MAAM,SAASM,MAAa,OAAN1F,GAAezC,EAAQ,CAACoI,gBAAiB,QAAQ,KAAMN,QAAS,WAAK9D,EAAQ,OAAQG,GAAYnE,SAG3I4D,EACC,0BAAUiE,MAAO/D,EAAU2D,KAAM3H,SA/U1B,SAACkB,GACd,IAAI+D,EAAM,GACVhB,GAAa,SAACsE,GAAD,mBAAC,eAAcA,GAAf,IAAsBZ,KAAKzG,EAAEE,OAAO2G,WACjDpE,EAAUL,EAAO2D,KAAI,SAACuB,GACpB,OAAGA,EAAKnD,IAAIzB,EACVqB,EAAG,2BAAOuD,GAAP,IAAab,KAAKzG,EAAEE,OAAO2G,QAGzBS,MAITnF,GADAA,EAAUA,EAAQyC,MAAM,EAAGtC,EAAc,IACvBJ,OAAO,CAAC,CAACE,OAAO,GAAD,mBAAMA,GAAN,CAAc2B,IAAM1B,MAAMA,KAC3DC,GAAe,KAmUR,eCnyBXiF,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.a8b0980d.chunk.js","sourcesContent":["import \"./App.css\";\n\nimport React, { useState, useRef, useEffect } from \"react\";\nimport { Stage, Layer, Circle, Text, Ellipse, Rect, Transformer, Line } from \"react-konva\";\nimport { v4 as uuid } from 'uuid';\nimport { Html } from \"react-konva-utils\";\n\n\nconst Rectangle = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n  return (\n    <React.Fragment>\n      <Rect\n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y(),\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n          const matrix = node.getAbsoluteTransform().getMatrix();\n          console.log(node.rotation())\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            width: Math.max(5, node.width() * scaleX),\n            height: Math.max(node.height() * scaleY),\n            rotation: node.rotation(),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\n\nconst Circles = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  return (\n    <React.Fragment>\n      <Circle\n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y(),\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            radius: Math.max(node.radius() * scaleX, node.radius() * scaleY),\n            rotation: node.rotation(),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.radius < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\nconst Texts = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n  \n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  \n  \n \n\n  return (\n    <React.Fragment>\n      <Text\n       \n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y()\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            \n            width: Math.max(5, node.width() * scaleX),\n            height: Math.max(node.height() * scaleY),\n            rotation: node.rotation(),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\nconst Lines = ({ shapeProps, isSelected, onSelect, onMove, onChange, points, tool, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n  \n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  \n  \n \n\n  return (\n    <React.Fragment>\n    \n      <Line\n       \n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        points={points}\n        stroke=\"#df4b26\"\n        strokeWidth={5}\n        tension={0.5}\n        lineCap=\"round\"\n        draggable={!useTool && isSelected}\n        globalCompositeOperation={\n          tool === 'eraser' ? 'destination-out' : 'source-over'\n        }\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y()\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n          \n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          let newPoints = [];\n          \n          for (let i=0; i<shapeProps.points.length; i=i+2){\n            newPoints = newPoints.concat([shapeProps.points[i]*scaleX, shapeProps.points[i+1]*scaleY]) \n            \n          }\n          onChange({\n            ...shapeProps,\n            // x: node.x(),\n            // y: node.y(),\n            // set minimal value\n            points: newPoints,\n            rotation: node.rotation(),\n            // width: Math.max(5, node.width() * scaleX),\n            // height: Math.max(node.height() * scaleY),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\nlet history = [{shapes: [], lines:[]}]\nlet historyStep = 0;\n\n\n\n\nexport default function App() {\n  const [circles, setCircles] = useState([]);\n  const [rectangles, setRectangles] = useState([]);\n  const [shapes, setShapes] = useState([]);\n  const [selectedId, selectShape] = useState(null);\n  const [textEdit, setTextEdit] = useState(false)\n  const [editShape, setEditShape] = useState(null)\n  const [tool, setTool] = React.useState('');\n  const [lines, setLines] = React.useState([]);\n  const isDrawing = React.useRef(false);\n  const [useTool, setUseTool] = useState(false)\n  const [handleDraw, setHandleDraw] = useState(false)\n\n  \nconst gridWidth = window.innerWidth/10\nconst gridHeight = window.innerHeight/5\n\nconst linesA = []\nconst linesB = []\n\n  for (let i = 0; i < window.innerHeight; i=i+gridHeight) {\n    linesA.push(\n      <Line\n        strokeWidth={0.5}\n        stroke={'gray'}\n        points={[0, i, window.innerWidth, i]}\n      />\n    )\n  }\n  for (let i = 0; i < window.innerWidth; i=i+gridWidth) {\n    linesB.push(\n      <Line\n        strokeWidth={0.5}\n        stroke={'gray'}\n        points={[i, 0, i, window.innerHeight]}\n      />\n    )\n  }\n  \n\n\n  const handleUndo = () => {\n    console.log('undo')\n    if (historyStep === 0) {\n      return;\n    }\n    historyStep -= 1;\n    const previous = history[historyStep];\n    setLines(previous.lines)\n    setShapes(previous.shapes)\n  }\n\n  const handleRedo = () => {\n    console.log('redo')\n    if (historyStep === history.length - 1) {\n      return;\n    }\n    historyStep += 1;\n    const next = history[historyStep];\n    setLines(next.lines)\n    setShapes(next.shapes)\n  }\n\n  const handleMouseDown = (e) => {\n    if(useTool){\n      isDrawing.current = true;\n      // const transform = e.target.getAbsoluteTransform().copy()\n      // transform.invert()\n      const stage = e.target.getStage()\n      let pos = stage.getPointerPosition();\n      // pos = transform.point(pos)\n      setLines([...lines, { tool, points: [pos.x, pos.y], name: \"line\", x: 0, y: 0, id: uuid() }]);\n      setShapes([...shapes, { tool, points: [pos.x, pos.y], name: \"line\", index: lines.length , x: e.target.x(), y: e.target.y(), id: uuid() }]);\n      \n      setHandleDraw(true)\n    }\n    checkDeselect(e)\n  };\n\n  const handleMouseMove = (e) => {\n    if(useTool){\n      if(handleDraw){\n        // no drawing - skipping\n        if (!isDrawing.current) {\n          return;\n        }\n        const stage = e.target.getStage();\n        const point = stage.getPointerPosition();\n        let lastLine = lines[lines.length - 1];\n        // add point\n        lastLine.points = lastLine.points.concat([point.x, point.y]);\n\n        // replace last\n        lines.splice(lines.length - 1, 1, lastLine);\n        setLines(lines.concat());\n\n        // let lastLine = ''\n        // for(var i=shapes.length-1; i > 0;i--){\n        //   if(shapes[i].name=='line'){\n        //     lastLine = shapes[shapes.length - 1];\n        //   }\n        // }\n\n        // // add point\n        // lastLine.points = lastLine.points.concat([point.x, point.y]);\n\n        // // replace last\n        // shapes.splice(shapes.length - 1, 1, lastLine);\n        // setShapes(shapes.concat());\n        }\n      }\n      \n    \n  };\n\n  const handleMouseUp = () => {\n    if(useTool){\n      isDrawing.current = false;\n      setHandleDraw(false)\n      history = history.slice(0, historyStep + 1);\n      history = history.concat([{shapes: shapes, lines:lines}]);\n      historyStep += 1;\n    }\n    \n  };\n\n  const checkDeselect = (e) => {\n    // deselect when clicked on empty area\n    const clickedOnEmpty = e.target === e.target.getStage();\n    if (clickedOnEmpty) {\n      selectShape(null);\n    }\n    setTextEdit(false)\n  };\n\n  const stageRef = useRef(null);\n  \n  const onDelete = (item) => {\n    setShapes((oldData) => {\n      return (oldData.filter((currentData, index) => {\n        return currentData.id !== item.id;\n      }))\n  })\n  setShapes((prevShape)=>(\n    [...prevShape, item]\n  ))\n  history = history.slice(0, historyStep + 1);\n  history = history.concat([{shapes: [...shapes, item], lines:lines}]);\n  historyStep += 1;\n}\n\n  const onEdit = (e) => {\n    let pos = {}\n    setEditShape((shape)=> ({...shape, text:e.target.value}))\n    setShapes(shapes.map((elem)=>{\n      if(elem.id==selectedId){\n        pos = {...elem, text:e.target.value}\n        return pos\n      }\n      return elem\n    })\n    )\n    history = history.slice(0, historyStep + 1);\n    history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n    historyStep += 1;\n  }\n\n  const handleSave = () => {\n    const data = JSON.stringify([shapes, lines])\n    localStorage.setItem('data', data);\n  }\n\n  useEffect(()=>{\n    const data = JSON.parse(localStorage.getItem('data'));\n    if(data){\n      setLines(data[1])\n      setShapes(data[0])\n      history = [{shapes: data[0], lines:data[1]}];\n      // historyStep += 1;\n    }\n  }, [])\n\n  \n  return (\n    <>\n    <Stage \n        \n        width={window.innerWidth} \n        height={window.innerHeight} \n        ref={stageRef} \n        onTouchStart={(e)=>{checkDeselect(e);handleMouseDown(e)}} \n        onMouseDown={handleMouseDown}\n        onTouchEnd={handleMouseUp}\n        onMousemove={handleMouseMove}\n        onTouchMove={handleMouseMove}\n        onMouseup={handleMouseUp}\n\n      >\n      <Layer>\n        \n        \n       \n        {linesA}\n        {linesB}\n\n\n      {shapes.map((eachShape, i)=> {\n        if(eachShape.name==\"rectangle\"){\n            return(\n              <Rectangle\n              key={i}\n              shapeProps={eachShape}\n              isSelected={eachShape.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(eachShape.id);\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = shapes.slice();\n                rects[i] = newAttrs;\n                setShapes(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: rects, lines:lines}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n            )\n        }\n        else if(eachShape.name==\"circle\"){\n            return(\n              <Circles\n             key={i}\n            shapeProps={eachShape}\n            isSelected={eachShape.id === selectedId}\n            onSelect={() => {\n              setUseTool(false)\n              onDelete(eachShape);\n              selectShape(eachShape.id);\n              \n            }}\n            onMove={()=>onDelete(eachShape)}\n            onChange={(newAttrs) => {\n              const rects = shapes.slice();\n              rects[i] = newAttrs;\n              setShapes(rects);\n              history = history.slice(0, historyStep + 1);\n              history = history.concat([{shapes: rects, lines:lines}]);\n              historyStep += 1;\n            }}\n            useTool={useTool}\n          />\n        )\n        }\n        else if(eachShape.name==\"text\"){\n          return(\n            <Texts\n              key={i}\n              shapeProps={eachShape}\n              isSelected={eachShape.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(eachShape.id);\n                setEditShape(eachShape)\n                setTextEdit(!textEdit)\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = shapes.slice();\n                rects[i] = newAttrs;\n                setShapes(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: rects, lines:lines}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n          )\n        }\n        else if(eachShape.name==\"line\"){\n         \n          return(\n            <Lines\n              key={i}\n              points={lines[eachShape.index].points}\n              tool={lines[eachShape.index].tool}\n              shapeProps={lines[eachShape.index]}\n              isSelected={lines[eachShape.index].id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(lines[eachShape.index].id);\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = lines.slice();\n                rects[eachShape.index] = newAttrs;\n                setLines(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: shapes, lines:rects}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n          )\n         \n        }\n      })\n      }\n      {/* <Line\n             x={200}\n             y={300}\n              points={[100, 100, 200, 200]}\n              stroke=\"#df4b26\"\n              strokeWidth={5}\n              tension={0.5}\n              lineCap=\"round\"\n              globalCompositeOperation={\n                'source-over'\n              }\n            /> */}\n      {/* {lines.map((line, i) => (\n            <Lines\n              key={i}\n              points={line.points}\n              tool={line.tool}\n              shapeProps={line}\n              isSelected={line.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(line);\n                selectShape(line.id);\n                \n              }}\n              onMove={()=>onDelete(line)}\n              onChange={(newAttrs) => {\n                const rects = lines.slice();\n                rects[i] = newAttrs;\n                setLines(rects);\n              }}\n            \n            />\n          ))} */}\n        \n      \n        <Circle\n          name=\"draggableCircle1\"\n          x={50}\n          y={70}\n          radius={25}\n          stroke=\"black\"\n          id=\"circle1\"\n        />\n        <Circle\n          name=\"draggableCircle\"\n          x={50}\n          y={70}\n          radius={25}\n          stroke=\"black\"\n          draggable={!useTool}\n          id=\"circle2\"\n          // onClick={()=>setUseTool(false)}\n          // onTap={()=>setUseTool(false)}\n          // onDragStart={()=>setUseTool(false)}\n          onDragEnd={(e) => {\n            \n            \n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), radius: 25, stroke:\"black\", id: uuid(), fill: \"red\", name:\"circle\" }\n            \n            setShapes((prevCircles) => [\n              ...prevCircles,\n              pos\n            ]);\n            console.log(shapes)\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableCircle = stage.findOne(\".draggableCircle\");\n            draggableCircle.position({ x: 50, y: 70 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n        />\n\n      <Rect\n        x= {25}\n        y= {100}\n        width= {50}\n        height= {50}\n        stroke=\"black\"\n        id= 'rect1'\n      />\n      <Rect\n        name=\"draggableRect\"\n        x= {25}\n        y= {100}\n        width= {50}\n        height= {50}\n        stroke=\"black\"\n        id= 'rect1'\n        draggable={!useTool}\n        \n        // onClick={()=>setUseTool(false)}\n        // onTap={()=>setUseTool(false)}\n        // onDragStart={()=>setUseTool(false)}\n        onDragEnd={(e) => {\n          \n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), stroke:\"black\", width: 50, height: 50, id: uuid(), fill: \"green\", name:\"rectangle\"}\n            setShapes((prevRectangles) => [\n              ...prevRectangles,\n              pos\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableRectangle = stage.findOne(\".draggableRect\");\n            draggableRectangle.position({ x: 25, y: 100 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n      />\n      <Text\n          fontSize={50}\n          text=\"T\"\n          width={40}\n          height={100}\n          x={35}\n          y={160}\n        />\n        <Text\n          name=\"draggableText\"\n          x={35}\n          y={160}\n          text=\"T\"\n          fontSize={50}\n          width={40}\n          height={100}\n          draggable={!useTool}\n          // onClick={()=>setUseTool(false)}\n          // onTap={()=>setUseTool(false)}\n          // onDragStart={()=>setUseTool(false)}\n          onDragEnd={(e) => {\n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), id: uuid(), text: \"T\", width: 40, textEditVisible:true, height:100, fontSize: 50, name:\"text\"}\n            setShapes((prevTexts) => [\n              ...prevTexts,\n              pos\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableText = stage.findOne(\".draggableText\");\n            draggableText.position({ x: 35, y: 160 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n      />\n     <Html>\n        <div>\n        <input type=\"button\" value=\"Undo\" onClick={handleUndo}/>\n        <input type=\"button\" value=\"Redo\" onClick={handleRedo} />\n        <input type=\"button\" value=\"Save\" onClick={handleSave} />\n        <br />\n        <input type=\"button\" value=\"Pencil\" style={tool=='pen' && useTool?{backgroundColor: \"aqua\"}:null} onClick={()=>{setTool('pen'); setUseTool(!useTool)}}/>\n        {/* <input type=\"button\" value=\"Eraser\" style={tool=='eraser' && useTool?{backgroundColor: \"aqua\"}:null} onClick={()=>{setTool('eraser'); setUseTool(!useTool)}} /> */}\n        </div>\n        {textEdit?\n          <textarea value={editShape.text} onChange={onEdit}></textarea>\n          :null\n        }\n     </Html>\n        </Layer>\n    </Stage>\n    \n    \n    </>\n  );\n}\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}