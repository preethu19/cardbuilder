{"version":3,"sources":["App.js","index.js"],"names":["Rectangle","shapeProps","isSelected","onSelect","onChange","onMove","useTool","shapeRef","React","useRef","trRef","useEffect","current","nodes","getLayer","batchDraw","Fragment","onDblClick","onDblTap","ref","draggable","onDragEnd","e","x","target","y","onTransformEnd","node","scaleX","scaleY","width","Math","max","height","boundBoxFunc","oldBox","newBox","Circles","radius","Texts","Lines","points","tool","stroke","strokeWidth","tension","lineCap","globalCompositeOperation","newPoints","i","length","concat","history","shapes","lines","historyStep","App","useState","setShapes","selectedId","selectShape","textEdit","setTextEdit","editShape","setEditShape","setTool","setLines","isDrawing","setUseTool","handleDraw","setHandleDraw","handleMouseDown","pos","getStage","getPointerPosition","name","id","uuid","index","checkDeselect","handleMouseMove","point","lastLine","splice","handleMouseUp","slice","stageRef","onDelete","item","oldData","filter","currentData","prevShape","window","innerWidth","innerHeight","onTouchStart","onMouseDown","onTouchEnd","onMousemove","onTouchMove","onMouseup","map","eachShape","newAttrs","rects","fill","prevCircles","console","log","findOne","position","prevRectangles","fontSize","text","textEditVisible","prevTexts","type","value","onClick","previous","next","style","backgroundColor","shape","elem","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.845056d2.chunk.js","sourcesContent":["import \"./App.css\";\n\nimport React, { useState, useRef, useEffect } from \"react\";\nimport { Stage, Layer, Circle, Text, Ellipse, Rect, Transformer, Line } from \"react-konva\";\nimport { v4 as uuid } from 'uuid';\nimport { Html } from \"react-konva-utils\";\n\n\nconst Rectangle = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n  return (\n    <React.Fragment>\n      <Rect\n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y(),\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            width: Math.max(5, node.width() * scaleX),\n            height: Math.max(node.height() * scaleY),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\n\nconst Circles = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n\n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  return (\n    <React.Fragment>\n      <Circle\n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y(),\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            radius: Math.max(node.radius() * scaleX, node.radius() * scaleY),\n            \n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.radius < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\nconst Texts = ({ shapeProps, isSelected, onSelect, onMove, onChange, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n  \n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  \n  \n \n\n  return (\n    <React.Fragment>\n      <Text\n       \n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        draggable={!useTool && isSelected}\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y()\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n\n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          onChange({\n            ...shapeProps,\n            x: node.x(),\n            y: node.y(),\n            // set minimal value\n            \n            width: Math.max(5, node.width() * scaleX),\n            height: Math.max(node.height() * scaleY),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\nconst Lines = ({ shapeProps, isSelected, onSelect, onMove, onChange, points, tool, useTool }) => {\n  const shapeRef = React.useRef();\n  const trRef = React.useRef();\n  \n  React.useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current]);\n      trRef.current.getLayer().batchDraw();\n    }\n  }, [isSelected]);\n\n  \n  \n \n\n  return (\n    <React.Fragment>\n    \n      <Line\n       \n        onDblClick={onSelect}\n        onDblTap={onSelect}\n        ref={shapeRef}\n        {...shapeProps}\n        points={points}\n        stroke=\"#df4b26\"\n        strokeWidth={5}\n        tension={0.5}\n        lineCap=\"round\"\n        draggable={!useTool && isSelected}\n        globalCompositeOperation={\n          tool === 'eraser' ? 'destination-out' : 'source-over'\n        }\n        // onDragStart={onMove}\n        // onTouchStart={onMove}\n        onDragEnd={(e) => {\n          \n          onChange({\n            ...shapeProps,\n            x: e.target.x(),\n            y: e.target.y()\n          });\n        }}\n        onTransformEnd={(e) => {\n          // transformer is changing scale of the node\n          // and NOT its width or height\n          // but in the store we have only width and height\n          // to match the data better we will reset scale on transform end\n          const node = shapeRef.current;\n          const scaleX = node.scaleX();\n          const scaleY = node.scaleY();\n          \n          // we will reset it back\n          node.scaleX(1);\n          node.scaleY(1);\n          let newPoints = [];\n          \n          for (let i=0; i<shapeProps.points.length; i=i+2){\n            newPoints = newPoints.concat([shapeProps.points[i]*scaleX, shapeProps.points[i+1]*scaleY]) \n            \n          }\n          onChange({\n            ...shapeProps,\n            // x: node.x(),\n            // y: node.y(),\n            // set minimal value\n            points: newPoints\n            // width: Math.max(5, node.width() * scaleX),\n            // height: Math.max(node.height() * scaleY),\n          });\n        }}\n      />\n      {isSelected && (\n        <Transformer\n          ref={trRef}\n          boundBoxFunc={(oldBox, newBox) => {\n            // limit resize\n            if (newBox.width < 5 || newBox.height < 5) {\n              return oldBox;\n            }\n            return newBox;\n          }}\n        />\n      )}\n    </React.Fragment>\n  );\n};\n\n\nlet history = [{shapes: [], lines:[]}]\nlet historyStep = 0;\n\n\nexport default function App() {\n  const [circles, setCircles] = useState([]);\n  const [rectangles, setRectangles] = useState([]);\n  const [shapes, setShapes] = useState([]);\n  const [selectedId, selectShape] = useState(null);\n  const [textEdit, setTextEdit] = useState(false)\n  const [editShape, setEditShape] = useState(null)\n  const [tool, setTool] = React.useState('');\n  const [lines, setLines] = React.useState([]);\n  const isDrawing = React.useRef(false);\n  const [useTool, setUseTool] = useState(false)\n  const [handleDraw, setHandleDraw] = useState(false)\n  \n\n  const handleUndo = () => {\n    console.log('undo')\n    if (historyStep === 0) {\n      return;\n    }\n    historyStep -= 1;\n    const previous = history[historyStep];\n    setLines(previous.lines)\n    setShapes(previous.shapes)\n  }\n\n  const handleRedo = () => {\n    console.log('redo')\n    if (historyStep === history.length - 1) {\n      return;\n    }\n    historyStep += 1;\n    const next = history[historyStep];\n    setLines(next.lines)\n    setShapes(next.shapes)\n  }\n\n  const handleMouseDown = (e) => {\n    if(useTool){\n      isDrawing.current = true;\n      // const transform = e.target.getAbsoluteTransform().copy()\n      // transform.invert()\n      const stage = e.target.getStage()\n      let pos = stage.getPointerPosition();\n      // pos = transform.point(pos)\n      setLines([...lines, { tool, points: [pos.x, pos.y], name: \"line\", x: 0, y: 0, id: uuid() }]);\n      setShapes([...shapes, { tool, points: [pos.x, pos.y], name: \"line\", index: lines.length , x: e.target.x(), y: e.target.y(), id: uuid() }]);\n      \n      setHandleDraw(true)\n    }\n    checkDeselect(e)\n  };\n\n  const handleMouseMove = (e) => {\n    if(useTool){\n      if(handleDraw){\n        // no drawing - skipping\n        if (!isDrawing.current) {\n          return;\n        }\n        const stage = e.target.getStage();\n        const point = stage.getPointerPosition();\n        let lastLine = lines[lines.length - 1];\n        // add point\n        lastLine.points = lastLine.points.concat([point.x, point.y]);\n\n        // replace last\n        lines.splice(lines.length - 1, 1, lastLine);\n        setLines(lines.concat());\n\n        // let lastLine = ''\n        // for(var i=shapes.length-1; i > 0;i--){\n        //   if(shapes[i].name=='line'){\n        //     lastLine = shapes[shapes.length - 1];\n        //   }\n        // }\n\n        // // add point\n        // lastLine.points = lastLine.points.concat([point.x, point.y]);\n\n        // // replace last\n        // shapes.splice(shapes.length - 1, 1, lastLine);\n        // setShapes(shapes.concat());\n        }\n      }\n      \n    \n  };\n\n  const handleMouseUp = () => {\n    if(useTool){\n      isDrawing.current = false;\n      setHandleDraw(false)\n      history = history.slice(0, historyStep + 1);\n      history = history.concat([{shapes: shapes, lines:lines}]);\n      historyStep += 1;\n    }\n    \n  };\n\n  const checkDeselect = (e) => {\n    // deselect when clicked on empty area\n    const clickedOnEmpty = e.target === e.target.getStage();\n    if (clickedOnEmpty) {\n      selectShape(null);\n    }\n    setTextEdit(false)\n  };\n\n  const stageRef = useRef(null);\n  \n  const onDelete = (item) => {\n    setShapes((oldData) => {\n      return (oldData.filter((currentData, index) => {\n        return currentData.id !== item.id;\n      }))\n  })\n  setShapes((prevShape)=>(\n    [...prevShape, item]\n  ))\n  history = history.slice(0, historyStep + 1);\n  history = history.concat([{shapes: [...shapes, item], lines:lines}]);\n  historyStep += 1;\n}\n\n  const onEdit = (e) => {\n    let pos = {}\n    setEditShape((shape)=> ({...shape, text:e.target.value}))\n    setShapes(shapes.map((elem)=>{\n      if(elem.id==selectedId){\n        pos = {...elem, text:e.target.value}\n        return pos\n      }\n      return elem\n    })\n    )\n    history = history.slice(0, historyStep + 1);\n    history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n    historyStep += 1;\n  }\n\n  \n  return (\n    <>\n    <Stage \n        width={window.innerWidth} \n        height={window.innerHeight} \n        ref={stageRef} \n        onTouchStart={(e)=>{checkDeselect(e);handleMouseDown(e)}} \n        onMouseDown={handleMouseDown}\n        onTouchEnd={handleMouseUp}\n        onMousemove={handleMouseMove}\n        onTouchMove={handleMouseMove}\n        onMouseup={handleMouseUp}\n      >\n      <Layer>\n        \n        \n       \n\n      {shapes.map((eachShape, i)=> {\n        if(eachShape.name==\"rectangle\"){\n            return(\n              <Rectangle\n              key={i}\n              shapeProps={eachShape}\n              isSelected={eachShape.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(eachShape.id);\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = shapes.slice();\n                rects[i] = newAttrs;\n                setShapes(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: rects, lines:lines}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n            )\n        }\n        else if(eachShape.name==\"circle\"){\n            return(\n              <Circles\n             key={i}\n            shapeProps={eachShape}\n            isSelected={eachShape.id === selectedId}\n            onSelect={() => {\n              setUseTool(false)\n              onDelete(eachShape);\n              selectShape(eachShape.id);\n              \n            }}\n            onMove={()=>onDelete(eachShape)}\n            onChange={(newAttrs) => {\n              const rects = shapes.slice();\n              rects[i] = newAttrs;\n              setShapes(rects);\n              history = history.slice(0, historyStep + 1);\n              history = history.concat([{shapes: rects, lines:lines}]);\n              historyStep += 1;\n            }}\n            useTool={useTool}\n          />\n        )\n        }\n        else if(eachShape.name==\"text\"){\n          return(\n            <Texts\n              key={i}\n              shapeProps={eachShape}\n              isSelected={eachShape.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(eachShape.id);\n                setEditShape(eachShape)\n                setTextEdit(!textEdit)\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = shapes.slice();\n                rects[i] = newAttrs;\n                setShapes(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: rects, lines:lines}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n          )\n        }\n        else if(eachShape.name==\"line\"){\n         \n          return(\n            <Lines\n              key={i}\n              points={lines[eachShape.index].points}\n              tool={lines[eachShape.index].tool}\n              shapeProps={lines[eachShape.index]}\n              isSelected={lines[eachShape.index].id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(eachShape);\n                selectShape(lines[eachShape.index].id);\n                \n              }}\n              onMove={()=>onDelete(eachShape)}\n              onChange={(newAttrs) => {\n                const rects = lines.slice();\n                rects[eachShape.index] = newAttrs;\n                setLines(rects);\n                history = history.slice(0, historyStep + 1);\n                history = history.concat([{shapes: shapes, lines:rects}]);\n                historyStep += 1;\n              }}\n              useTool={useTool}\n            />\n          )\n         \n        }\n      })\n      }\n      {/* <Line\n             x={200}\n             y={300}\n              points={[100, 100, 200, 200]}\n              stroke=\"#df4b26\"\n              strokeWidth={5}\n              tension={0.5}\n              lineCap=\"round\"\n              globalCompositeOperation={\n                'source-over'\n              }\n            /> */}\n      {/* {lines.map((line, i) => (\n            <Lines\n              key={i}\n              points={line.points}\n              tool={line.tool}\n              shapeProps={line}\n              isSelected={line.id === selectedId}\n              onSelect={() => {\n                setUseTool(false)\n                onDelete(line);\n                selectShape(line.id);\n                \n              }}\n              onMove={()=>onDelete(line)}\n              onChange={(newAttrs) => {\n                const rects = lines.slice();\n                rects[i] = newAttrs;\n                setLines(rects);\n              }}\n            \n            />\n          ))} */}\n\n        <Circle\n          name=\"draggableCircle1\"\n          x={50}\n          y={70}\n          radius={25}\n          stroke=\"black\"\n          id=\"circle1\"\n        />\n        <Circle\n          name=\"draggableCircle\"\n          x={50}\n          y={70}\n          radius={25}\n          stroke=\"black\"\n          draggable={!useTool}\n          id=\"circle2\"\n          // onClick={()=>setUseTool(false)}\n          // onTap={()=>setUseTool(false)}\n          // onDragStart={()=>setUseTool(false)}\n          onDragEnd={(e) => {\n            \n            \n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), radius: 25, stroke:\"black\", id: uuid(), fill: \"red\", name:\"circle\" }\n            \n            setShapes((prevCircles) => [\n              ...prevCircles,\n              pos\n            ]);\n            console.log(shapes)\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableCircle = stage.findOne(\".draggableCircle\");\n            draggableCircle.position({ x: 50, y: 70 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n        />\n\n      <Rect\n        x= {25}\n        y= {100}\n        width= {50}\n        height= {50}\n        stroke=\"black\"\n        id= 'rect1'\n      />\n      <Rect\n        name=\"draggableRect\"\n        x= {25}\n        y= {100}\n        width= {50}\n        height= {50}\n        stroke=\"black\"\n        id= 'rect1'\n        draggable={!useTool}\n        \n        // onClick={()=>setUseTool(false)}\n        // onTap={()=>setUseTool(false)}\n        // onDragStart={()=>setUseTool(false)}\n        onDragEnd={(e) => {\n          \n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), stroke:\"black\", width: 50, height: 50, id: uuid(), fill: \"green\", name:\"rectangle\"}\n            setShapes((prevRectangles) => [\n              ...prevRectangles,\n              pos\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableRectangle = stage.findOne(\".draggableRect\");\n            draggableRectangle.position({ x: 25, y: 100 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n      />\n      <Text\n          fontSize={50}\n          text=\"T\"\n          width={40}\n          height={100}\n          x={35}\n          y={160}\n        />\n        <Text\n          name=\"draggableText\"\n          x={35}\n          y={160}\n          text=\"T\"\n          fontSize={50}\n          width={40}\n          height={100}\n          draggable={!useTool}\n          // onClick={()=>setUseTool(false)}\n          // onTap={()=>setUseTool(false)}\n          // onDragStart={()=>setUseTool(false)}\n          onDragEnd={(e) => {\n            // push new circle to view\n            // note that we must push circle first before returning draggable circle\n            // because e.target.x returns draggable circle's positions\n            const pos = { x: e.target.x(), y: e.target.y(), id: uuid(), text: \"T\", width: 40, textEditVisible:true, height:100, fontSize: 50, name:\"text\"}\n            setShapes((prevTexts) => [\n              ...prevTexts,\n              pos\n            ]);\n\n            // return draggable circle to original position\n            // notice the dot (.) before \"draggableCircle\"\n            var stage = stageRef.current;\n            var draggableText = stage.findOne(\".draggableText\");\n            draggableText.position({ x: 35, y: 160 });\n            history = history.slice(0, historyStep + 1);\n            history = history.concat([{shapes: [...shapes, pos], lines:lines}]);\n            historyStep += 1;\n          }}\n      />\n     <Html>\n        <div>\n        <input type=\"button\" value=\"Undo\" onClick={handleUndo}/>\n        <input type=\"button\" value=\"Redo\" onClick={handleRedo} />\n        <br />\n        <input type=\"button\" value=\"Pencil\" style={tool=='pen' && useTool?{backgroundColor: \"aqua\"}:null} onClick={()=>{setTool('pen'); setUseTool(!useTool)}}/>\n        {/* <input type=\"button\" value=\"Eraser\" style={tool=='eraser' && useTool?{backgroundColor: \"aqua\"}:null} onClick={()=>{setTool('eraser'); setUseTool(!useTool)}} /> */}\n        </div>\n        {textEdit?\n          <textarea value={editShape.text} onChange={onEdit}></textarea>\n          :null\n        }\n     </Html>\n        \n      </Layer>\n    </Stage>\n    \n    \n    </>\n  );\n}\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}